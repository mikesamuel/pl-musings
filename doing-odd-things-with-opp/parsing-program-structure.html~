<!doctype html>
<html lang="en">
<meta charset="utf-8">
<title>Simpler, error-tolerant parsers for {C.like;} languages</title>
<link rel="stylesheet" href="../css/common.css" />
<style>
  #tio-input { white-space: pre-wrap }

  /* parts of speech */
  .pos-stmt { background: #fbb; border: 3px solid red }
  .pos-type { background: #bbf; border: 3px dashed blue }
  .pos-expr { background: #ff8; border: 3px double #9b870c }

  button.copy-to-tio { float: right }


  #flattening-example-table tr { background-color: transparent }
  #flattening-example-table td {
      border: 0; text-align: center;
      font-family: "Inconsolata", "Consolas", "Lucida Console", "Monaco", monospace;
  }
</style>

<script
  src="https://code.jquery.com/jquery-3.4.1.min.js"
  integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
  crossorigin="anonymous"></script>
<script src="../js/html.js"></script>
<script src="../js/inline-testing.js"></script>

<script src="../js/parse-tree-test-fns.js"></script>
<link rel="stylesheet" href="../css/parse-tree-styles.css" />

<link rel="stylesheet" href="../css/sshow.css" />
<script src="../js/sshow.js"></script>

<p id="preamble">
  Fyi, this is a design document for
  <a href="https://temperlang.dev">Temper</a>, a programming
  language for high-assurance libraries that run inside anything.
</p>

<h1 id="top">Simpler, error-tolerant parsers for <code>{C.like;}</code> languages</h1>
<small><a id="teststatus"></a></small>

<p>
  Error tolerant parsing techniques for C-like languages to enable
  better tool integration, partial analysis, language extensibility,
  and meta-programming.
</p>

<p>
  <b>Keywords</b>: combinators, homoiconicity, IDE, meta-programming,
  operator-precedence, parsing, quasiquotation
</p>


<ol id="toc"></ol>

<h2 id="abstract">Abstract</h2>

<p>
  Most developers are
  <a href="https://insights.stackoverflow.com/survey/2019#technology-_-programming-scripting-and-markup-languages">familiar</a>
  with languages whorse surface syntax is "C-like": C, C++, C#, Go,
  Java, JavaScript, Perl, Rust, Scala, Swift, and TypeScript.  But the
  complexity of parsing C-like languages makes it hard to achieve what
  Lisps take for granted.
</p>

<p>
  Lisps reuse a few syntactic constructs that transparently relate to
  commonly used datatypes.  This makes it easy for programmer tools to
  deal with program fragments, for designers to extend the language
  with new special forms or macros, and for programs to manipulate
  programs as data.
</p>

<p>
  Lispers often group these benefits under the rubric of &ldquo;homoiconicity&rdquo;.
  That term has
  <a href="http://www.expressionsofchange.org/dont-say-homoiconic/">some</a>
  <a href="http://calculist.org/blog/2012/04/17/homoiconicity-isnt-the-point/">problems</a>,
  so this document adopts goals attributed to homoiconicity but does
  not claims that any resulting language is homoiconic.  These goals
  include:
</p>

<ul>
  <li>
    <p>
      The coarse-grained structure of a program can be inferred
      without a grammar rule per special form.
    <p>
      This lets tools easily analyzing a fragment of a larger
      program at the lowest appropriate level of abstraction.
      For example, test coverage tools and dynamic call graph generators
      instrument programs but can often operate on a token stream.
  </li>

  <li>Common syntactic errors can be isolated to part of a parse tree.
    This is important when a developer is editing code.
    <ul>
      <li>IDEs should be able to derive some type information to
        suggest appropriate completions, even when the expression
        containing the cursor is malformed.
      <li>If an input to a REPL fails to parse, the REPL should be
        able to localize the error to a fragment, and re-present the
        input with the cursor at a convenient place.
    </ul>
    <p>
      It also lets tools provide degraded service when given a
      program that uses a new special form.
  <li>
    Program generating programs can reuse the small number of rules
    with extensions.
  </li>

  <li>
    Non-onerous syntactic constraints allow common flow-insensitive
    analyses like matching uses of symbols with declarations to be
    performed by simple tools without converting a parse tree to an
    AST or taking into account other source files.
  </li>
</ul>

<p>
  Unfortunately large grammars make it hard for tools simpler than the
  compiler to accurately deal with program fragments, to degrade
  gracefully, or to deal with code as data.  This limits a diverse
  tool ecosystems to languages with a large community that can afford
  the engineering effort.
</p>

<p>
  This document introduces a way for niche languages to use familar
  C-like syntax and hopefully still support a diverse tool ecosystem.
  Specifically it
</p>
<ul>
  <li>
    Discusses <i>developers' intuitions</i> about C-like
    languages that help them reason about partial programs, broken
    programs, or brokens with unfamiliar special forms,
  </li>
  <li>
    Formalizes those intuitions via a <i>cover grammar</i> for
    C-like statement constructs and catalogues exceptions to the
    rule,
  </li>
  <li>
    Defines an <i>operator-precedence parser</i> for C-like languages
    that reuses a small number of rules,
  </li>
  <li>
    Catalogues sources of <i>non-context-free</i>ness in some widely-used
    C-like languages, and how to avoid those in new languages,
  </li>
  <li>
    Defines a context-free <i>lexer</i> which recognizes complicated lexical
    constructs from JavaScript and Perl but which, unlike those languages,
    does not require scannerless parsing,
  </li>
  <li>
    Evaluates the same on <i>partial & broken inputs</i> to see how well it
    localizes damage to the parse tree,
  </li>
  <li>
    Catalogues the ways that a parse tree derived from a partial or
    broken input may fail generic <i>well-formedness checks</i>,
  </li>
  <li>
    Shows how <i>parser combinators</i> can be used to derive ASTs from
    parse trees, including partial or broken parse trees, for a toy language,
  </li>
  <li>
    Extends the toy language with <i>quasiquotation</i> syntax,
  </li>
  <li>
    <i>Suggests</i> ways language implementors can craft a grammar to
    take full advantage of this approach.
  </li>
</ul>


<h2 id="covering-grammars">Covering Grammars</h2>


<p>
  Grammars with many, fine-grained rules can do a good job preventing
  nonsensical inputs from confusing later compiler stages, but
  typically produce either a parse tree, or error messages, not both.
</p>

<table class="grammar">
  <tr><td><span class="nonterm">Statement</span><td>::==<td><span><span class="term">for</span><td><span class="term">(</span> <span class="nonterm">Stuff</span> <span class="term">)</span> <span class="term">{</span> <span class="nonterm">Stuff</span> <span class="term">}</span></tr>
  <tr><td><td>/<span><td><span class="term">if</span><td><span class="term">(</span> <span class="nonterm">Stuff</span> <span class="term">)</span> <span class="term">{</span> <span class="nonterm">Stuff</span> <span class="term">}</span> &hellip;</tr>
  <tr><td><td>/<span><td><span class="term">while</span><td><span class="term">(</span> <span class="nonterm">Stuff</span> <span class="term">)</span> <span class="term">{</span> <span class="nonterm">Stuff</span> <span class="term">}</span></tr>
  <tr><td><td>/<span><td>&hellip;</tr>
</table>

<p>
  A large grammar like this could adapt to account for common
  developer errors and to deal with partial inputs, but this takes
  engineering effort per rule, and makes the grammar even larger.
</p>

<pre style="line-height: 1.05em">
if ( x ) { fn<span class="problem-tokens">(</span>; }

   &#x2517;&#x2501;&#x2501;&#x2501;&#x251b; &#x2503;   &#x2579;  &#x2503;
         &#x2517;&#x2501;&#x2501;&#x2501;&#x2501;&#x2501;&#x2501;&#x251b;
</pre>

<p id="programmer-intuitions">
  A parser that degrades gracefully on inputs like the above,
  should recognize the kind of rules-of-thumb that programmers
  use to reason about broken inputs:
</p>
<ul>
  <li>like brackets pair,</li>
  <li>curlies group statements,</li>
  <li>semicolons separate statements,</li>
  <li>commas separate expressions</li>
</ul>

<p>
  The grammar above has a lot of repetition.
  In languages with C-like grammars, most of the flow control special
  forms, and some other special forms (like JavaScript's
  <code>function(...) {...}</code>) follow the
  convention:
</p>

<table class="grammar">
  <tr><td><span class="nonterm">Statement</span><td>::==<td><span><span class="nonterm">keyword</span> <i>[</i> <span class="term">(</span> <span class="nonterm">Stuff</span> <span class="term">)</span> <i>]</i> <span class="term">{</span> <span class="nonterm">Stuff</span> <span class="term">}</span> &hellip; </tr>
</table>

<p>
  A <g><i>cover grammar</i></g> is a grammar that matches all strings
  matched by some &ldquo;covered&rdquo; grammars so that a later pass
  can disambiguate between them.  For example, consider the JavaScript
  expression <code class="prettyprint">(a = null) =&gt; (a =
  null)</code>.  In it, <code class="prettyprint">(a = null)</code>
  appears twice, once as a formal parameter list with a default value,
  and once as an assignment.  To avoid reparsing based on whether a
  <code>=&gt;</code> follows the close parenthesis, JavaScript
  engines often use a cover grammar for <i>FormalParameterList</i>
  and <i>PrimaryExpression</i>.
</p>

<p>
  We can formalize developers' intuitions about a language by
  crafting a few rules that cover the myriad rules in the full grammar.
  This lets a few error recovery strategies tuned to programmers'
  intuitions carry much weight.
</p>

<p>
  Each of the branches for <span class="nonterm">Statement</span>
  above looks like a function application followed by a block, but
  there are a some conventions which distinguish these from normal
  function calls.
</p>

<ul>
  <li>They start with a reserved keyword.</li>
  <li>Declarations inside the parentheses, when allowed, are visible
  within the curly bracket block (<code>{&hellip;}</code>).</li>
  <li>Declarations in either are not visible outside the
    whole.
    <small>(This was not the case in
    <a href="https://stackoverflow.com/a/1287867/20394">C89 and earlier</a>
    but was
    <a href="http://port70.net/~nsz/c/c11/n1570.html#6.8.5.3p1">fixed in C99</a>
    and languages since have followed suit.)</small>
  </li>
  <li>Execution of statements in <code>{&hellip;}</code> may be executed
  late, multiply, or not at all.</li>
</ul>

<p>
  Additionally, certain keywords allow chaining these constructs, e.g.
  <span class="term">else</span>.
</p>

<p>
  Most C-like flow control constructs can be covered by a single rule:
</p>

<table class="grammar" id="cover-grammar">
<tr><td><span class="nonterm">FlowControl</span></td>     <td>::==<td><span class="nonterm">Keyword</span> <span class="nonterm">ParenPart<sub>opt</sub></span> <span class="nonterm">Tail</span>;</tr>
<tr><td><span class="nonterm">ParenPart</span></td>       <td>::==<td><span class="term">(</span> <span class="nonterm">TokenSoup</span> <span class="term">)</span>;</tr>
<tr><td><span class="nonterm">ParenPart<sub>opt</sub></span></td><td>::==<td><span class="nonterm">ParentPart</span> / &epsilon;;</tr>
<tr><td><span class="nonterm">Tail</span><td>::==<td><span class="term">{</span> <span class="nonterm">TokenSoup</span> <span class="term">}</span> <span class="nonterm">MoreFlowControl</span></tr>
<tr><td><td>/<td><span class="term">;</span>;</tr>
<tr><td><span class="nonterm">MoreFlowControl</span></td> <td>::==<td><span class="nonterm">InfixKeyword</span> <span class="nonterm">FlowControl</span></tr>
<tr><td></td>                <td>/</td><td>&epsilon;;</tr>
<tr><td><span class="nonterm">InfixKeyword</span></td>    <td>::==<td><span class="term">else</span> <span class="term">if</span> / <span class="term">else</span> / <span class="term">catch</span> / <span class="term">finally</span>;</tr>
</table>

<p>
  <a href="#wrinkle1">Not</a> <a href="#wrinkle2">all</a> follow this convention but
  <a href="#parsing-statements">many do</a>, and below we detail how to handle exceptions
  to the rule.
</p>


<h2 id="stages">Stages</h2>

<p>
  This document builds a parser in JavaScript so that it can run in
  your browser.  You can see below that the parser operates in three
  stages:
</p>

<div>
<ol class="slideshow" style="width: 24em; min-height: 11em"
    id="staging-slideshow">
  <li><h4 class="no-toc">Input: Source Text</h4>
    &ldquo;<code><span data-ss-id="0">f</span><!--
      --><span data-ss-id="1">(</span><!--
      --><span data-ss-id="2">x</span><!--
      --><span data-ss-id="3"> </span><!--
      --><span data-ss-id="4">+</span><!--
      --><span data-ss-id="5"> </span><!--
      --><span data-ss-id="6">y</span><!--
      --><span data-ss-id="7">)</span><!--
      --><span data-ss-id="8">;</span></code>&rdquo;
  <li><h4 class="no-toc">Lexical Phase: Source Text &rarr; Tokens</h4>
    <span class="token" data-ss-id="0">f</span>
    <span class="token" data-ss-id="1">(</span>
    <span class="token" data-ss-id="2">x</span>
    <span class="token" data-ss-id="3"> </span>
    <span class="token" data-ss-id="4">+</span>
    <span class="token" data-ss-id="5"> </span>
    <span class="token" data-ss-id="6">y</span>
    <span class="token" data-ss-id="7">)</span>
    <span class="token" data-ss-id="8">;</span>
  <li><h4 class="no-toc">Parse Phase: Tokens &rarr; Parse Tree</h4>
    <span class="tnode" data-ss-id="9">
      <span class="tnode" data-ss-id="10">
        <span class="tnode" data-ss-id="11">
          <span class="tleaf" data-ss-id="0">f</span>
        </span>
        <span class="tleaf" data-ss-id="1">(</span>
        <span class="tnode" data-ss-id="12">
          <span class="tnode" data-ss-id="13">
            <span class="tleaf" data-ss-id="2">x</span>
          </span>
          <span class="tleaf" data-ss-id="4">+</span>
          <span class="tnode" data-ss-id="14">
            <span class="tleaf" data-ss-id="6">y</span>
          </span>
        </span>
        <span class="tleaf" data-ss-id="7">)</span>
      </span>
      <span class="tleaf" data-ss-id="8">;</span>
    </span>
  <li><h4 class="no-toc">Final Phase: Parse Tree &rarr; Abstract Syntax Tree</h4>
    <div class="ast" data-ss-id="9"><span class="type">stmt</span>
      <div class="ast"><span class="type">expr</span>
        <div class="ast" data-ss-id="10"><span class="type">call</span>
          <div class="ast"><span class="type">expr</span>
            <div class="ast" data-ss-id="11"><span class="type">id</span>
              <span class="astleaf" data-ss-id="0">f</span>
            </div>
          </div>
          <div class="ast"><span class="type">actuals</span>
            <div class="ast"><span class="type">expr</span>
              <div class="ast" data-ss-id="12"><span class="type">binaryop</span>
                <div class="ast"><span class="type">expr</span>
                  <div class="ast" data-ss-id="13"><span class="type">id</span>
                    <span class="astleaf" data-ss-id="2">x</span>
                  </div>
                </div>
                <span class="astleaf" data-ss-id="4">+</span>
                <div class="ast"><span class="type">expr</span>
                  <div class="ast" data-ss-id="14"><span class="type">id</span>
                    <span class="astleaf" data-ss-id="6">y</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
</ol>
</div>

<script>
  animateSlideShows();
  document.getElementById('staging-slideshow').autorunSlideShow();
</script>

<p>
  Before jumping into code, it's worth defining some terms.
  For the purposes of this document:
</p>

<!-- TODO: instead, link uses in grammar.html -->
<dl>
  <dt>Token</dt>
  <dd>
    A substring of a program fragment with some diagnostic metadata.
    Tokens may be malformed, e.g. an unclosed quoted string.
  </dd>

  <dt>Significant token</dt>
  <dd>A token that is not a comment or ignorable whitespace.</dd>

  <dt>Parse Tree</dt>
  <dt>Concrete Syntax Tree (CST)</dt>
  <dd>
    A tree such that leaves are tokens and a preorder enumeration of
    leaves yields the significant tokens from which it was parsed.
  </dd>

  <dt>Abstract Syntax Tree (AST)</dt>
  <dd>
    A tree such that each node is either a token, or is a collection
    of sub-trees and a tag that identifies a production in the
    language's abstract grammar.

    <p>
      An AST need not contain all significant tokens, e.g. an
      implementation might drop parentheses used merely for grouping,
      or tokens like &ldquo;<tt>if</tt>&rdquo; which are implicit in
      the tag.

    <p>
      An inner AST node may have the special <i>error</i> tag in which
      case its children are a soup of tokens to which later passes should
      not assign clear semantics.
  </dd>

  <dt>Lexer</dt>
  <dd>
    Partitions source text into a stream of tokens.
  </dd>

  <dt>Parser</dt>
  <dd>
    A consumer of a stream of tokens that produces a parse tree.
  </dd>

  <dt>Combinator</dt>
  <dd>
    A consumer of a stream that builds a structured output based on
    declarative rules describing patterns involving sequences of
    stream elements.
  </dd>
</dl>

<h2 id="precedence">Precedence</h2>

<p>
  Operator precedence parsers reuse a few simple rules.  It's
  straightforward to craft such a parser to produce a parse tree for
  every input so they recover well from many kinds of syntax errors.
  Instead of having a grammar rule for each language construct, an
  operator precedence parser behaves like a grammar driven parser with
  just one rule per kind of operator:
</p>

<table class="grammar" id="operand-grammar">
<tr><td><span class="nonterm">Operand</span></td>     <td>::==<td><span class="nonterm">PrefixOperator</span> <span class="nonterm">Operand</span></tr>
<tr><td><td>|<td><span class="nonterm">Operand</span> <span class="nonterm">InfixOperator</span> <span class="nonterm">Operand</span></tr>
<tr><td><td>|<td><span class="nonterm">Operand</span> <span class="nonterm">TernaryOperator</span> <span class="nonterm">Operand</span> <span class="nonterm">TernaryFollower</span> <span class="nonterm">Operand</span></tr>
<tr><td><td>|<td><span class="nonterm">Operand</span> <span class="nonterm">OpenBracket</span> <span class="nonterm">Operand</span> <span class="nonterm">CloseBracket</span></tr>
<tr><td><td>|<td><span class="nonterm">Operand</span> <span class="nonterm">PostfixOperator</span></tr>
<tr><td><td>|<td><span class="nonterm">Operand</span><sup>?</sup> (<span class="nonterm">Separator</span> <span class="nonterm">Operand</span><sup>?</sup>)<sup>+</sup></tr>
<tr><td><td>|<td><span class="nonterm">SimpleOperand</span>;</tr>
</table>

<p>
  Operator precedence parsers use &ldquo;operators&rdquo; to figure out
  how to turn a series of tokens into a tree structure.  This lets us
  infer parentheses in expressions and to identify when a keyword like
  <code>else</code> or the <code>while</code> in <code>do...while...</code>
  groups things to its immediate left and right.
  So <span class="nonterm">PrefixOperator</span> defines which operators
  can appear before their operands like the &lsquo;-&rsquo; in
  &ldquo;<code>-x</code>&rdquo;;
  <span class="nonterm">InfixOperator</span> defines which can appear
  in the middle like the &lsquo;+&rsquo; in
  &ldquo;<code>x+y</code>&rdquo;.
</p>

<p>
  An operator precedence parser still needs to decide how to group
  operands: for example, if
  <span class="nonterm">InfixOperator</span>::==<span class="term">+</span>|<span class="term">&times</span>;
  then na&iuml;vely applying the grammar above to
  &ldquo;<code>a&times;b+c</code>&rdquo; would give two possible
  inerpretations: <i>(a&times;b)+c</i> and <i>a&times;(b+c)</i>.
</p>

<p>
  Operator precedence parsers use an order over operators to avoid
  ambiguity.  This order gives <i>precedence</i> to some operators
  and answers the question &ldquo;Can this operator contain that
  operator unparenthesized?&rdquo; For example, if &lsquo;+&rsquo; can
  contain &lsquo;&times;&rsquo; unparenthesized but not vice versa
  then valid interpretations of &ldquo;<code>a&times;b+c</code>&rdquo;
  include
  <i>(a&times;b)+c</i> but not <i>a&times;(b+c)</i>.
</p>

<p>
  Here is an operator precedence table similar to those that appear in
  user-documentation for <a href="https://en.cppreference.com/w/c/language/operator_precedence">C</a>, <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html">Java</a> (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.2">normative</a>), and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">JavaScript</a> which gives a
  foundation for our precedence relation.
</p>

<script class="visible">
// An operator has
//   tok       : string   - a token
//   prec      : number   - a precedence value.  Higher binds more tightly.
//   type      : string   - the type of operator in
//                          (INFIX, POSTFIX, PREFIX, SEPARATOR, TOKEN).
//   assoc     : string   - associativity in (LEFT, RIGHT)
//   followers : string[] - for ternary ops, tokens that continue the operation.
//   closer    : boolean  - true iff the operator requires a close bracket.

// Operator types
const INFIX     = 'INFIX';
const POSTFIX   = 'POSTFIX';
const PREFIX    = 'PREFIX';
const SEPARATOR = 'SEPARATOR';  // For operators like ';' and ',' which separate
                                // operands, any of which may be missing.
const TOKEN     = 'TOKEN';  // Distinguishes leaf nodes from operator nodes.

// Associativities
const LEFT    = 'LEFT';
const RIGHT   = 'RIGHT';

const operators = [
  { tok: '.',       prec: 18, type: INFIX,   assoc: LEFT },
  // Bracket operators are groups by themselves.
  { tok: '(',       prec: 18, type: PREFIX,                closer: true },
  { tok: '[',       prec: 18, type: PREFIX,                closer: true },
  // Used infix, a bracket is like a function call.
  { tok: '(',       prec: 18, type: INFIX,   assoc: LEFT,  closer: true },
  // See '{...}' farther down
  { tok: '[',       prec: 18, type: INFIX,   assoc: LEFT,  closer: true },

  { tok: '++',      prec: 17, type: POSTFIX },
  { tok: '--',      prec: 17, type: POSTFIX },

  { tok: '++',      prec: 16, type: PREFIX },
  { tok: '--',      prec: 16, type: PREFIX },
  { tok: '+',       prec: 16, type: PREFIX },
  { tok: '-',       prec: 16, type: PREFIX },
  { tok: '!',       prec: 16, type: PREFIX },
  { tok: '~',       prec: 16, type: PREFIX },
  // Pointer/reference prefix operators in C++, Go, Rust.
  { tok: '&',       prec: 16, type: PREFIX },
  { tok: '*',       prec: 16, type: PREFIX },

  // There is another flavour of '<' below.  See "Less-than ambiguity".
  { tok: '<',       prec: 15, type: INFIX,   assoc: LEFT,  closer: true },
  { tok: 'new',     prec: 15, type: PREFIX },
  // TODO: 'extends', 'instanceof', 'as' probably go here.

  { tok: '**',      prec: 14, type: INFIX,   assoc: LEFT },

  { tok: '*',       prec: 13, type: INFIX,   assoc: LEFT },
  { tok: '/',       prec: 13, type: INFIX,   assoc: LEFT },
  { tok: '%',       prec: 13, type: INFIX,   assoc: LEFT },

  { tok: '+',       prec: 12, type: INFIX,   assoc: LEFT },
  { tok: '-',       prec: 12, type: INFIX,   assoc: LEFT },

  { tok: '<<',      prec: 11, type: INFIX,   assoc: LEFT },
  { tok: '>>',      prec: 11, type: INFIX,   assoc: LEFT },
  { tok: '>>>',     prec: 11, type: INFIX,   assoc: LEFT },

  { tok: '<',       prec: 10, type: INFIX,   assoc: LEFT },
  { tok: '<=',      prec: 10, type: INFIX,   assoc: LEFT },
  { tok: '>',       prec: 10, type: INFIX,   assoc: LEFT },
  { tok: '>=',      prec: 10, type: INFIX,   assoc: LEFT },
  { tok: 'in',      prec: 10, type: INFIX,   assoc: LEFT },

  { tok: '==',      prec: 9,  type: INFIX,   assoc: LEFT },
  { tok: '!=',      prec: 9,  type: INFIX,   assoc: LEFT },
  { tok: '===',     prec: 9,  type: INFIX,   assoc: LEFT },
  { tok: '!==',     prec: 9,  type: INFIX,   assoc: LEFT },

  { tok: '&',       prec: 8,  type: INFIX,   assoc: LEFT },

  { tok: '^',       prec: 7,  type: INFIX,   assoc: LEFT },

  { tok: '|',       prec: 6,  type: INFIX,   assoc: LEFT },

  { tok: '&&',      prec: 5,  type: INFIX,   assoc: LEFT },

  { tok: '||',      prec: 4,  type: INFIX,   assoc: LEFT },

  // A ternary operator.
  { tok: '?',       prec: 3,  type: INFIX,   assoc: RIGHT, followers: [ ':' ] },
  { tok: ':',       prec: 3,  type: INFIX,   assoc: LEFT },
  // Infix '{' is used in keyword (expression) { statements; }
  { tok: '{',       prec: 3,  type: INFIX,   assoc: RIGHT, closer: true },
  { tok: '{',       prec: 3,  type: PREFIX,                closer: true },

  // Assignment operators
  { tok: '=',       prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '+=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '-=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '*=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '/=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '%=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '&=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '^=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '|=',      prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '&&=',     prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '||=',     prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '<<=',     prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '>>=',     prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '>>>=',    prec: 2,  type: INFIX,   assoc: RIGHT },
  { tok: '=~',      prec: 2,  type: INFIX,   assoc: RIGHT },

  // Appears in variadic signatures and in array/object creation.
  { tok: '...',     prec: 1,  type: PREFIX,  assoc: RIGHT },

  // Comma is an odd ducks since they separate non-expression
  // productions that themselves contain expressions, e.g. in
  // formal argument lists and variable declaration lists in
  // many languages.
  { tok: ',',       prec: 0,  type: SEPARATOR },
];
</script>

<p>
  We need to be able to match up brackets.
</p>

<script class="visible">
const bracketPartners = new Map([
  [ '(', ')' ],
  [ '{', '}' ],
  [ '[', ']' ],
  [ '<', '>' ],
]);
</script>

<script class="visible hoisted" id="extra-brackets-for-quasis">
// Extra brackets for quasi-quoting
bracketPartners.set('\\{', '}');
bracketPartners.set('\\(', ')');
bracketPartners.set('${', '}');
operators.push(
  { tok: '\\(',     prec: 18, type: PREFIX,                closer: true },
  { tok: '\\{',     prec: 18, type: PREFIX,                closer: true },
  { tok: '${',      prec: 18, type: PREFIX,                closer: true },
);
</script>

<p>
  Some derived tables simplify later code greatly.
</p>

<script class="visible">
const openBrackets  = new Set();
const closeBrackets = new Set();
for (const [ open, close ] of [...bracketPartners.entries()]) {
  openBrackets.add(open);
  closeBrackets.add(close);
}
</script>


<p>
  These operators give arithmetic & logical expressions theit usual meanings.
</p>

<script>
  tp('1 - 1 - 1', [ [ [ '1' ], '-', [ '1' ] ], '-', [ '1' ]]);
  tp('1 - 1 * 1', [ [ '1' ], '-', [ [ '1' ], '*', [ '1' ] ] ]);
  tp('1 * 1 - 1', [ [ [ '1' ], '*', [ '1' ] ], '-', [ '1' ] ]);
  tp('a = b = c', [ [ 'a' ], '=', [ [ 'b' ], '=', [ 'c' ] ] ]);
  tp('!!b', [ '!', [ '!', [ 'b' ] ] ]);
  tp('a && b || c == d', [ [ ['a'], '&&', ['b']], '||', [['c'], '==', ['d'] ]]);
  tp('a - -b', [ [ 'a' ], '-', [ '-', [ 'b' ] ] ]);
</script>

<p>
  Note: Herein, parse trees are shown with a rectangle around each
  inner node.  Click the expando (&#x25b6;) to see an indented view of
  the same.  These diagrams are generated programatically by the
  described parser running as JavaScript in your browser.
</p>

<h3 id="less-than-ambiguity">Less-than ambiguity</h3>

<p id="bracket-ambig">There is a deep, unavoidable ambiguity in C++,
Java, and probably Rust.  A &lsquo;&lt;&rsquo; token may be either
infix operator less-than or the start of an angle bracketed group of
type parameters.  Consider the partial token sequence &hellip;
<code class="prettyprint">f ( a &lt; b , c &gt; d )</code>
&hellip; in Java:</p>

<pre class="prettyprint lang-java">
public &lt;b, c&gt; int <u>f(a&lt;b, c&gt; d)</u> {
  //   &#x21e7;    &#x21e7;        &#x21e7;    &#x21e7;
  // Angle brackets group type parameters in a method signature.

  return d.<u>f(a &lt; b, c &gt; d)</u>;
  //           &#x21e7;      &#x21e7;
  // Using less than, greater than to compute actual parameters.
}
</pre>

<p>
  This is a real problem and this document only provides a partial
  solution to this ambiguity.  We take a cue from TypeScript which
  allows types (and hence type parameters) in a few readily identifiable
  contexts:
</p>
<ul>
  <li>As the right operand of a few infix operators like
    &lsquo;:&rsquo;, &ldquo;as&rdquo;, &ldquo;extends&rdquo;,
    &ldquo;instanceof&rdquo;, and &ldquo;new&rdquo;.
    Since <a href="#colon-meanings">&lsquo;:&rsquo; can precede
    labeled statements</a> this may not be perfect.
  <li>As the right operand of &lsquo;=&rsquo; when it appears in
    a &ldquo;type&rdquo; declaration.</li>
  <li>In deprecated <code>&lt;typecast&gt;</code> syntax which we
    ignore.</li>
</ul>

<p>
  Here's how things parse when our operator precedence function
  only allows <code>&lt;&hellip;&gt;</code> to the right of the
  operators listed above.
</p>

<script>
  tp(
    'f(a<b, c>d)',
    [
      ['f'],
      '(',
      [
        [['a'], '<', ['b']],
        ',',
        [['c'], '>', ['d']],
      ],
      ')',
    ]
  );
  tp(
    'f(d: a<b, c>)',
    [
      ['f'],
      '(',
      [
        ['d'],
        ':',
        [
          ['a'],
          '<',
          [
            ['b'],
            ',',
            ['c'],
          ],
          '>',
        ],
      ],
      ')',
    ]
  );
  tp(
    `\
// multiple closers in  '>>='
let a: Array<Array<number>>= [[]];`,
    [
      [
        [
          ['let', 'a'],
          ':',
          [
            ['Array'],
            '<',
            [
              ['Array'],
              '<',
              ['number'],
              '>',
            ],
            '>',
          ],
        ],
        '=',
        [
          '[',
          [
            '[',
            ']',
          ],
          ']',
        ],
      ],
      ';',
    ],
  );
tp(
  'boolean x = a ? a : b < c && c > d;',
  [
    [
      ['boolean', 'x'],
      '=',
      [
        ['a'],
        '?',
        ['a'],
        ':',
        [
          [['b'], '<', ['c']],
          '&&',
          [['c'], '>', ['d']],
        ],
      ],
    ],
    ';',
  ],
);
tp(
  'type nums = Set<number>;',
  [
    [
      ['type', 'nums'],
      '=',
      [
        ['Set'],
        '<',
        ['number'],
        '>',
      ],
    ],
    ';',
  ]
);
</script>

<p>Note: <a href="https://facebook.github.io/jsx/#syntax"><i>JSXElement</i>s</a>
like (<code class="prettyprint">image = &lt;img src={src}&gt;</code>)
do not require parse-time disambiguation.  The code herein does not
handle JSX, but later sections introduce mechanisms that should extend
to that use case.  Specifically, <a href="#lexing">lexing</a> explains
how to use one token of lookbehind to decide whether &lsquo;/&rsquo;
starts a division operator or a regular expression literal.  A similar
approach could decide whether a &lsquo;&lt;&rsquo; starts an operator
or a JSX block.  Also, <a href="#token-preparsing">preparsing</a>
talks about a technique to group template literal parts which would
help handle JSX.</p>

<details>
  <summary>Dead-end: &ldquo;Part-of-speech&rdquo; tagging</summary>

  <h4 id="part-of-speech-tagger">Dead-end: &ldquo;Part-of-speech&rdquo; tagging</h4>

  <p>
    This approach was found to be brittle, and hard to build confidence in.
    It is included to document a dead-end.
  </p>

<p>It may be possible to resolve ambiguities, like angle bracket ambiguity,
would be to provide additional context cues to the parser.</p>

<p>A <i>part-of-speech tagger</i> could run as a part of the pre-parse
processing pass over tokens to add context usable by the operator precedence
function.  Parts of speech might include:</p>

<ul>
  <li>An <span class="pos-expr">expression</span> is entered on
  &lsquo;(&rsquo;, &lsquo;[&rsquo;, &lsquo;=&rsquo; (reset by
  &lsquo;,&rsquo;), &lsquo;;&rsquo; in parens</li>
  <li>A <span class="pos-stmt">statement</span> is entered on statement
  keyword or &lsquo;;&rsquo; not in parens.
  <li>A <span class="pos-type">type</span> is entered on &lsquo;as&rsquo;
  (TypeScript infix cast operator) or &lsquo;:&rsquo; in parens or
  following declaration keyword, but not following
  &lsquo;?&rsquo;</li>
</ul>

<p>This example shows two distinct uses of &lsquo;&lt;&rsquo;: once to
bracket type parameters, and later as a comparison operator.  It also
shows three distinct uses of &lt;{&gt;: first to start a statement
block, then o bracket a record type, and finally to construct a
record.</p>

<p>An operator precedence function that used part-of-speech cues could
assign different precedences to these different uses.</p>

<script>
  tpos(
    '{ let o : { x: (T<P> | null) } = { x: a < b && c > d ? f() : g() }; }',
    [
      ['stmt', ['{', 'let', 'o']],
      ['type', [':', '{', 'x', ':', '(', 'T', '<', 'P', '>', '|', 'null', ')', '}']],
      ['expr', ['=', '{', 'x', ':', 'a', '<', 'b', '&&', 'c', '>', 'd',
                '?', 'f','(', ')', ':', 'g', '(', ')', '}']],
      ['stmt', [';', '}']],
    ]
  );
  tpos(
    'a = new T<A, B<C, D>, E>(a<b, c>d).foo();\nlbl: function f(x:T=null) : bool { return x instanceof Object; }',
    [
      ['stmt', ['a']],
      ['expr', ['=', 'new']],
      ['type', ['T', '<', 'A', ',', 'B', '<', 'C', ',', 'D', '>', ',', 'E', '>']],
      ['expr', ['(', 'a', '<', 'b', ',', 'c', '>', 'd', ')']],
      ['stmt', ['.', 'foo']],
      ['expr', ['(', ')']],
      ['stmt', [';', 'lbl', ':', 'function', 'f']],
      ['expr', ['(', 'x']],
      ['type', [':', 'T']],
      ['expr', ['=', 'null', ')']],
      ['type', [':', 'bool']],
      ['stmt', ['{', 'return']],
      ['expr', ['x', 'instanceof']],
      ['type', ['Object']],
      ['stmt', [';', '}']],
    ]
  );
  tpos(
    'new A(a < b, c > d);',
    [
      ['stmt', ['new']],
      ['type', ['A']],
      ['expr', ['(', 'a', '<', 'b', ',', 'c', '>', 'd', ')']],
      ['stmt', [';']],
    ]
  );
</script>

<p>Here's a tagger that seems to work well for TypeScript, but is brittle.</p>

<script class="visible">
/** Given a series of tokens, returns the same series but with a pos field. */
function *tagPartsOfSpeech(tokens) {
  const contextStack = [
    {
      closer: null,  // Token text that pops this element
      pos: 'stmt',   // The part of speech
      pos0: 'stmt',  // Part of speech returned to on ','
      oncolon: null,  // What to do on a colon
      oncolon0: null,
    },
  ];
  // Keep two tokens worth of lookbehind
  let lookbehind0 = null;
  let lookbehind1 = null;
  for (const token of tokens) {
    const { tok } = token;
    const { length: n } = contextStack;
    let top = contextStack[n - 1];
    let { pos } = top;
    switch (tok) {
    case '(': case '[': case '{':
      let oncolon = null;
      let pos0 = null;
      if (tok === '{') {
        if (pos === 'expr') {
          if (lookbehind0 === '=>') {
            pos = 'stmt';
          } else {
            oncolon = 'expr';
          }
        } else if (pos === 'type'
                   && !(lookbehind0 === '|' || lookbehind0 === ':'
                       || lookbehind0 === ',' || lookbehind0 === '<')) {
          pos = top.pos0;
        }
      } else if (lookbehind0 === 'for' && tok === '(') {
        pos0 = 'expr';
        pos = 'stmt';
      } else if (tok === '(' && pos === 'type'
                 && lookbehind0 !== '|' && lookbehind0 !== '<'
                 && lookbehind0 !== ',' && lookbehind0 !== ':') {
        pos = 'expr';
      } else if (pos === 'stmt') {
        pos = 'expr';
      }
      contextStack.push({
        closer: bracketPartners.get(tok),
        pos,
        pos0: pos0 || pos,
        oncolon0: null,
        oncolon,
      });
      break;
    case '}': case ']': case ')': case '>':
      for (let i = n; --i > 0;) {
        if (tok === contextStack[i].closer) {
          contextStack.length = i;
          break;
        }
      }
      break;
    case '<':
      if (pos === 'type') {
        top.pos = top.pos0;
        contextStack.push({
          closer: '>',
          pos,
          pos0: pos,
          oncolon0: null,
          oncolon: null,
        });
      }
      break;
    case ':':
      if (pos === 'stmt' && WORD_RE.test(lookbehind0)
          && (lookbehind1 === null || lookbehind1 === ';'
              || lookbehind1 === '}')) {
        // Labeled statement
      } else {
        pos = top.pos = top.oncolon || 'type';
      }
      break;
    case '=':
      pos = top.pos = 'expr';
      break;
    case ';': case ',':
      pos = top.pos = top.pos0;
      top.oncolon = top.oncolon0;
      break;
    case '?':
      contextStack[n - 1].oncolon = 'expr';
      break;
    // Keywords
    case 'as': case 'instanceof': case 'extends': case 'new':
      top.pos = 'type';
      break;
    case 'assert': case 'return': case 'throw': case 'yield':
      top.pos = 'expr';
      break;
    case 'case': case 'default':
      top.pos = top.pos0 = 'expr';
      top.oncolon = top.oncolon0 = 'stmt';
      break;
    }
    yield { ...token, pos };
    lookbehind1 = lookbehind0;
    lookbehind0 = tok;
  }
}
</script>

<p>This tagger is a fairly complicated push-down automaton, but
languages for which it's possible to specify may be able to exploit
that fact to simplify their precedence functions.</p>

</details>


<h3 id="flow-control-joiners">Flow control joiners</h3>

<p>Besides that, expressions in C-like languages are a good fit for
precedence tables like this.  It turns out that statements can be
shoe-horned in with a wrinkle though.
As <a href="#cover-grammar">discussed</a>, most flow control
constructs in C-like languages have the form <code>keyword (expression)
statement</code>.</p>

<p>There are a few keywords that precede blocks but that always follow
statements.  And &lsquo;<code>;</code>&rsquo; separates statements.</p>

<script class="visible">
operators.push(
  { tok: 'else',    prec: -1, type: INFIX,   assoc: RIGHT },
  { tok: 'catch',   prec: -1, type: INFIX,   assoc: LEFT },
  { tok: 'finally', prec: -1, type: INFIX,   assoc: LEFT },

  { tok: ';',       prec: -2, type: SEPARATOR },
);
</script>

<h3 id="statement-parsing">Statement parsing</h3>
<p id="parsing-statements">With this, we're ready to parse some statements.</p>

<script>
  tp(
    'if (e) { stmt }',
    [
      [
        [ 'if' ],
        '(',
        [ 'e' ],
        ')',
      ],
      '{',
      [ 'stmt' ],
      '}',
    ]
  );
  tp(
    'if (e) { stmt } else { stmt }',
    [
      [
        [
          [ 'if' ],
          '(',
          [ 'e' ],
          ')',
        ],
        '{',
        [ 'stmt' ],
        '}',
      ],
      'else',
      [
        '{',
        [ 'stmt' ],
        '}',
      ],
    ]
  );
  tp(
    'while (e) { stmt }',
    [
      [
        [ 'while' ],
        '(',
        [ 'e' ],
        ')',
      ],
      '{',
      [ 'stmt' ],
      '}',
    ]
  );
  tp(
    'for (e;e;e) { stmt }',
    [
      [
        [ 'for' ],
        '(',
        [
          [ 'e' ],
          ';',
          [ 'e' ],
          ';',
          [ 'e' ]
        ],
        ')',
      ],
      '{',
      [ 'stmt' ],
      '}',
    ]
  );
  tp(
    'for (t e in e) { stmt }',
    [
      [
        [ 'for' ],
        '(',
        [
          [ 't', 'e' ],
          'in',
          [ 'e' ],
        ],
        ')',
      ],
      '{',
      [ 'stmt' ],
      '}',
    ]
  );
  tp(
    'try (decl) { stuff }',
    [
      [
        [ 'try' ],
        '(',
        [ 'decl' ],
        ')'
      ],
      '{',
      [ 'stuff' ],
      '}'
    ]
  );
  tp(
    'try (decl) { stuff } catch (e) { stuff } finally { stuff }',
    [
      [
        [
          [
            [ 'try' ],
            '(',
            [ 'decl' ],
            ')'
          ],
          '{',
          [ 'stuff' ],
          '}'
        ],
        'catch',
        [
          [
            '(',
            [ 'e' ],
            ')'
          ],
          '{',
          [ 'stuff' ],
          '}'
        ]
      ],
      'finally',
      [
        '{',
        [ 'stuff' ],
        '}'
      ]
    ]
  );
  tp(
    'function (a,b,c) { stuff }',
    [
      [
        [ 'function' ],
        '(',
        [
          [ 'a' ],
          ',',
          [ 'b' ],
          ',',
          [ 'c' ]
        ],
        ')'
      ],
      '{',
      [ 'stuff' ],
      '}'
    ]
  );
  tp(
    'with (x) { stuff() }',
    [
      [
        [ 'with' ],
        '(',
        [ 'x' ],
        ')'
      ],
      '{',
      [
        [ 'stuff' ],
        '(',
        ')',
      ],
      '}'
    ]
  );
  tp(
    '{}',
    [
      '{',
      '}',
    ]
  );
  tp(
    '{;}',
    [
      '{',
      [ ';' ],
      '}',
    ]
  );
  tp(
    '{f();}',
    [
      '{',
      [
        [
          [ 'f' ],
          '(',
          ')',
        ],
        ';',
      ],
      '}',
    ]
  );
</script>

<h3 id="do-hellip-while">do&hellip;while</h3>
<p id="wrinkle2">Except that in <code>do{...}while(...);</code>
the <code>while</code> appears like an infix operator, but only directly
inside a <code>do</code> which acts like a prefix operator.</p>

<script class="visible">
// LATER: some special precedence handling when a while follows a do.
operators.push(
  { tok: 'do',      prec: -1, type: PREFIX,  assoc: LEFT },
  { tok: 'while',   prec: -1, type: INFIX,   assoc: LEFT },
);
</script>

<script>
  tp(
    'do { stuff } while (!done);',
    [
      [
        [
          'do',
          [
            '{',
            [ 'stuff' ],
            '}',
          ],
        ],
        'while',
        [
          '(',
          [
            '!',
            [ 'done' ]
          ],
          ')'
        ],
      ],
      ';',
    ]
  );
</script>

<h3 id="flavours-of-colon">Flavours of colon</h3>  <!-- Did that come out wrong? -->

<p id="colon-meanings">
  Also, &lsquo;:&rsquo; is odd.  It seems to have widely distinct
  precedences:
</p>

<ul>
  <li>Paired with a &lsquo;?&rsquo; it acts as part of a ternary operator.
    <script>
  tp(
    'x = a ? b : c ? d : e;',
    [
      [
        [ 'x' ],
        '=',
        [
          [ 'a' ],
          '?',
          [ 'b' ],
          ':',
          [
            [ 'c' ],
            '?',
            [ 'd' ],
            ':',
            [ 'e' ],
          ]
        ]
      ],
      ';'
    ]
  );
  tp(
    'x = a ? b ? c : d : e;',
    [
      [
        [ 'x' ],
        '=',
        [
          [ 'a' ],
          '?',
          [
            [ 'b' ],
            '?',
            [ 'c' ],
            ':',
            [ 'd' ],
          ],
          ':',
          [ 'e' ],
        ]
      ],
      ';'
    ]
  );
    </script>
  </li>
  <li id="wrinkle1">
    After <code>case</code> or <code>default</code> it acts as a
    postfix operator and terminates any expression.
    <script>
  tp(
    'switch (e) { case 0: stuff; default: break; }',
    [
      [
        [ 'switch' ],
        '(',
        [ 'e' ],
        ')'
      ],
      '{',
      [
        [
          'case',
          [ '0' ],
        ],
        ':',
      ],
      [
        [ 'stuff' ],
        ';',
      ],
      [
        [ 'default' ],
        ':',
      ],
      [
        [ 'break' ],
        ';',
      ],
      '}'
    ]
  );
    </script>
  </li>
  <li>
    It separates a label from a statement.
    <script>
  tp(
    'label: for (;;) {}',
    [
      [ 'label' ],
      ':',
      [
        [
          [ 'for' ],
          '(',
          [
            ';',
            ';'
          ],
          ')',
        ],
        '{',
        '}',
      ],
    ]
  );
    </script>
  </li>
  <li>
    Otherwise it's an infix operator that separates keys from values
    or typed items from types.
    <script>
  tp(
    'const x : { key: valueType } = { key: valueExpr };',
    [
      [
        [
          [ 'const', 'x' ],
          ':',
          [
            '{',
            [
              [ 'key' ],
              ':',
              [ 'valueType' ],
            ],
            '}',
          ],
        ],
        '=',
        [
          '{',
          [
            [ 'key' ],
            ':',
            [ 'valueExpr' ],
          ],
          '}',
        ]
      ],
      ';',
    ]
  );
    </script>
  </li>
</ul>

<p>
  Some recent, C-like languages have less &lsquo;:&rsquo;-ambiguity.
  Kotlin, for example, uses &lsquo;@&rsquo; in
  <a href="https://kotlinlang.org/docs/reference/grammar.html#label"
     >labeled statements</a>
  and allows &ldquo;if&hellip;else&hellip;&rdquo;
  <a href="https://kotlinlang.org/docs/reference/grammar.html#ifExpression"
     >in expressions</a>
  in lieu of a ternary operator.
</p>

<script class="visible">
// LATER: special precedence handling when a colon terminates a
// case or default clause.
operators.push(
  { tok: 'case',    prec: -3, type: PREFIX },
  { tok: 'default', prec: -3, type: PREFIX },
  // Only allowed in case or default.
  { tok: ':',       prec: -3, type: POSTFIX },
);
</script>

<h3 id="infix-curly-brackets">Infix curly brackets</h3>

<p>
  There's one more wrinkle.  In <code class="prettyprint">keyword
  (expr) { stmt; }</code>, the <code>{}</code>s act as an infix
  operator like the <code>()</code>s.  This is not what we want for
  the second pair of <code>{}</code>s in <code>while (b) {x} {y}</code>.
  In C-like languages, <code>{y}</code> is a block that
  executes separately from, and after the <code>while</code>
  construct.  So we will disallow chaining of <code>{}</code> as an
  infix operator.
</p>

<script>
  tp(
    'while (b) {} {}',
    [
      [
        [
          [ 'while' ],
          '(',
          [ 'b' ],
          ')'
        ],
        '{',
        '}',
      ],
      [
        '{',
        '}'
      ]
    ]
  );
</script>

<h3 id="expression-preceding-keywords">Expression preceding keywords</h3>

<p>
  Defining prefix operators for keywords like <code>return</code>
  that precede bare expressions ensures we won't get a different parse tree
  depending on whether parentheses are present, and <code>return-1</code>
  won't parse to infix &lsquo;-&rsquo; as it should in <code>x-1</code>.
</p>

<script class="visible">
operators.push(
  { tok: 'assert',  prec: -1, type: PREFIX },
  { tok: 'return',  prec: -1, type: PREFIX },
  { tok: 'throw',   prec: -1, type: PREFIX },
  { tok: 'yield',   prec: -1, type: PREFIX },
);
</script>

<script>
  tp(
    'return x;',
    [
      ['return', ['x']],
      ';',
    ]
  );
  tp(
    'return (x);',
    [
      [
        'return',
        [
          '(',
          [ 'x' ],
          ')',
        ],
      ],
      ';',
    ]
  );
  tp(
    'return;',
    [
      ['return'],
      ';',
    ]
  );
  tp(
    'return -1;',
    [
      [
        'return',
        [
          '-',
          ['1'],
        ],
      ],
      ';',
    ]
  );
  tp(
    'x -1;',
    [
      [
        ['x'],
        '-',
        ['1'],
      ],
      ';',
    ]
  );
  tp(
    'throw e || new Error();',
    [
      [
        'throw',
        [
          ['e'],
          '||',
          [
            [
              'new',
              ['Error'],
            ],
            '(',
            ')',
          ],
        ],
      ],
      ';',
    ]
  );
  tp(
    'throw;',
    [
      [
        'throw',
      ],
      ';',
    ],
    { problems: [ { left: 0, right: 5, message: 'Missing operand' } ] },
  );
</script>

<h3 id="an-operator-precedence-function">An operator precedence function</h3>
<p>
  Knowing all this, we're ready to craft our answer to
  &ldquo;Can this operator contain that one unparenthesized?&rdquo;:
</p>

<script class="visible" id="can-nest-defn">
// A bogus operator which can be outer to anything.
// This lets us start parsing.
const rootOperator  = { tok: '',   prec: -(1 << 30), type: PREFIX };
// A bogus operator for nodes like numbers, identifiers, string literals.
const notAnOperator = { tok: null, prec: +(1 << 30), type: TOKEN };

/**
 * Given operators, true when an operator stack consisting of outers
 * can contain the inner operator.
 *
 * @param inner a stack element.
 * @param outers a function such that
 *    outers(0) is the stack element that would directly contain inner,
 *    outers(n + 1) contains outers(n) or is null.
 */
function canNest(outers, inner) {
  if (inner.op === rootOperator) {
    // The root can't nest in anything.
    return false;
  }

  const outer = outers(0);

  // Make sure that at most one flavour of '<' is allowed.
  if (inner.op.tok === '<'
      // If there's no node content, then we're asking whether
      // this can go in outer, not whether something can go
      // in it.
      && inner.node.length === 0) {
    if (isTypeContext(outers) === !inner.op.closer) {
      return false;
    }
  }

  // do{...}while(...); is weird.
  if (outer.op.tok === 'while') {
    return inner.op.tok === 'do' || inner.op.tok === '(';
  }

  // postfix : is only allowed to wrap 'case' and 'default'.
  if (outer.op.tok === ':' && outer.op.type === POSTFIX) {
    return inner.op.tok === 'case' || inner.op.tok === 'default';
  }

  // Chained applications of infix {} is a problem for
  //     while(b) {...}
  //     {...}
  if (outer.op.tok === '{' && openBracketCount(outer) === 0
      && inner.op.tok === '{' && outer.node.length === 0) {
    return false;
  }

  if (outer.op.closer && outer.node.length) {
    // Open brackets can contain anything.
    // Completed bracket operators can't contain anything.
    return needsCloseBracket(outer);
  }

  // new is a prefix operator, but we want function application
  // to apply to it as a whole, not just its type argument.
  // This avoids problems over function application having high
  // precedence, but type operators like <...> having lower precedence.
  if (inner.op.tok === 'new' && inner.node.length
      && outer.op.tok === '(' && !outer.node.length
      && outer.op.type === INFIX) {
    return true;
  }

  // Normal operator precedence comparison.
  if (outer.op.prec < inner.op.prec) {
    return true;
  }

  // Handle associative operators.
  if (outer.op.prec === inner.op.prec
      && (outer.op.assoc !== RIGHT
          // Parser calls canNest twice for infix operators since
          // it inserts between existing elements of the operator
          // stack, but we only need to check associativity once.
          || (inner.op.type === INFIX && inner.node.length === 0))) {
    return true;
  }

  return false;
}

/**
 * Per less-than ambiguity, <...> can
 *   +  appear in a ':' operator (e.g. `id : type<...>`),     or
 *   +  appear to the right of 'new', 'instanceof', 'as',     or
 *   +  nest in itself (e.g. `type<type<...>>`),              or
 *   +  nest in parentheses (e.g. `(type<...>)`),             or
 *   +  nest in `|` (e.g. `type0 | type1<...>`),              or
 *   +  nest in ',' (e.g. `type<param0<...>, param1<...>>`)   or
 *   +  appear to the right of certain '=', (e.g. `type t = u<...>`.
 */
function isTypeContext(outers) {
  for (let depth = 0;; ++depth) {
    const ancestor = outers(depth);
    if (!ancestor) {
      return false;
    }
    const { tok } = ancestor.op;
    if (tok === ':' || tok === 'new' /* TODO: etc. */) {
      return true;
    }
    if (tok === '=') {
      // Expect ancestor.node to be  something like ['type', 'name']
      return ancestor.node[0] && ancestor.node[0][0]
          && ancestor.node[0][0].tok === 'type';
    }
    if (tok === '|' || tok === ','
        || (tok === '(' && ancestor.op.type === INFIX)
        || (tok == '<' && ancestor.op.closer)) {
      continue;
    }
    break;
  }
  return false;
}
</script>

<p>
  This function takes &gt;50 lines of code to handle legacy constructs
  and corner cases from a slew of languages to demonstrate that
  handling these is feasible.  An equivalent function for a language
  that did not need to support all these corner cases might be much
  simpler.  For example, using <tt>[&hellip;]</tt> to group type
  parameters, a la Scala, would obviate half of this code.
</p>

<p>
  This function depends on some bookkeeping functions to juggle brackets.
</p>

<script class="visible">
/**
 * A node "needs" a close bracket if it has an open bracket like '('
 * without a corresponding ')'.
 *
 * This tests whether the count of open brackets exceeds the count
 * of close brackets without worrying about whether open parenthesis ('(')
 * pairs properly close square (']').
 *
 * For example, these need a close
 *   foo(x   // An incomplete application of an infix bracket operator
 *   [       // An incomplete prefix bracket operation
 *   { stmt  // Another incomplete prefix bracket operation with one operand.
 * but these do not
 *   foo(x)
 *   []
 *   { stmt }
 *   [ 0 , 1 )
 *   ( ) )   // Extra closed does not need a close
 */
function needsCloseBracket(stackElement) {
  return openBracketCount(stackElement) > 0;
}

/**
 * True if the given stack element needs an operand, assuming there is no
 * uncommitted stack element above it on the stack.
 */
function needsOperand({ op, node }) {
  if (op.type === INFIX || top.type === PREFIX) {
    const lastIndex = node.length - 1;
    // If it ends with an operator token, then it needs an operand.
    return lastIndex < 0 || typeof node[lastIndex].tok === 'string';
  }
  return false;
}

/**
 * The count of open brackets minus the count of close brackets.
 *
 * Returns resultIfNegative if it is not undefined and any prefix
 * of tokens contains more close brackets than open brackets.
 */
function openBracketCount(
    { node, op: { tok, closer } },
    resultIfNegative = undefined
) {
  if (!closer) {
    // This returns a sensible value for non bracket operators, including
    // infix '<' (less than operator) which needs to be treated differently
    // from angle brackets used in types like `T<X>`.
    return 0;
  }
  let count = 0;
  for (const { tok } of node) {
    if (closeBrackets.has(tok)) {
      --count;
      if (count < 0 && resultIfNegative !== undefined) {
        return resultIfNegative;
      }
    } else if (openBrackets.has(tok)) {
      ++count;
    }
  }
  return count;
}
</script>

<h3 id="separators">Separators</h3>

<p>
  This works pretty well but there are a few quirks worth mentionining.
</p>

<p>
  Many languages define comma (<code>,</code>) as a binary operator
  that evaluates both operands, in order, and uses the right's result.
</p>

<p>
  But commas appear in other contexts.
<p>

<pre class="prettyprint">
// Commas can be used as an operator
(0, obj).f() // `.f` does not receieve obj as the thisValue
// They often appear in for-loop parts.
for (i = 0, j = 10; i != j; ++i, --j) { ... }

// In an argument list, a trailing comma is allowed
f(
  actual<sub>0</sub>, actual<sub>1</sub>, actual<sub>2</sub>,
)

// Adjacent commas surround an array "hole".
array = [0,,2]

// A tailing comma is allowed in an array and may be the only comma.
array = [,]
</pre>

<p>
  Commas seem like <i>prefix</i> operators in <code>[,]</code>, like
  <i>infix</i> operators in expessions, and possibly in argument lists,
  and like <i>postfix</i> operators at the end of an argument list.
</p>

<p>
  We instead treat comma and semicolon as none of these operator
  types.  Instead we define SEPARATOR as a new operator type which
  may appear between any number of operands at a particular precedence
  level and which tolerates missing operands.  Since it may have more
  than two operands, separators do not have any associativity.
</p>

<script>
  tp(
    'f(actual\u2080,actual\u2081,actual\u2082);',
    [
      [
        [ 'f' ],
        '(',
        [
          [ 'actual\u2080' ],
          ',',
          [ 'actual\u2081' ],
          ',',
          [ 'actual\u2082' ],
        ],
        ')',
      ],
      ';',
    ]
  );
</script>
<p>
  Semicolons (&lsquo;;&rsquo;) are also separators which is
  convenient in
</p>
<script>
  tp(
    'for (init;cond;incr) {}',
    [
      [
        [ 'for' ],
        '(',
        [
          [ 'init' ],
          ';',
          [ 'cond' ],
          ';',
          [ 'incr' ],
        ],
        ')',
      ],
      '{',
      '}',
    ]
  );
</script>

<p>
  In for loops, parts are optional. &ldquo;<code>for (;;) {}</code>&rdquo;.
</p>

<script>
  tp(
    'for (;;) {}',
    [
      [
        [ 'for' ],
        '(',
        [
          ';',
          ';',
        ],
        ')'
      ],
      '{',
      '}'
    ]
  );
</script>

<p>This also shows up when you have multiple adjacent NOPs.</p>
<script>
  tp(
    '{ ;;; }',
    [
      '{',
      [
        ';',
        ';',
        ';',
      ],
      '}',
    ]
  );
</script>


<h2 id="parsing">Parsing</h2>

<p>
  Before defining the parser, we abstract out the set of operators.
  (This is just a wrapper for our <code>operators</code> array, but
  the abstraction will come in handy later when talking about
  user-defined operators a la Scala.)
</p>

<script class="visible">
const EMPTY_ARRAY = Object.freeze([]);
const EMPTY_SET = Object.freeze(new Set());

class OperatorSet {
  /** All operators, o, such that o.type===type&&o.tok===tokenText. */
  operators(type, tokenText) {
    throw new Error('pure abstract');
  }

  /**
   * A maximal set of outputs of this.operators(x, tokenText)
   * such that for each member, o, o.followers.indexOf(tokenText) >= 0.
   * Followers are used to handle ternary expressions: (cond ? this : that).
   */
  followedBy(tokenText) {
    throw new Error('pure abstract');
  }

  // TODO: whether something is an open bracket or a close
  // bracket should move here.
}

/** An operator set constructed from an array of operators. */
class ClosedOperatorSet extends OperatorSet {
  constructor(operators) {
    super();
    // Group entries to make it easy to find a relevant operator definition.
    this.typeToTokenToOperators = new Map();
    // Group followers for ternary ops.
    this.followerMap = new Map();

    for (const operator of operators) {
      const { tok, type, followers } = operator;
      let tokenToOperators = this.typeToTokenToOperators.get(type);
      if (!tokenToOperators) {
        this.typeToTokenToOperators.set(type, tokenToOperators = new Map());
      }
      let operatorArray = tokenToOperators.get(tok);
      if (!operatorArray) {
        tokenToOperators.set(tok, operatorArray = []);
      }
      operatorArray.push(operator);
      if (followers) {
        for (const follower of followers) {
          let ops = this.followerMap.get(follower);
          if (!ops) {
            this.followerMap.set(follower, ops = new Set());
          }
          ops.add(operator);
        }
      }
    }
  }

  operators(type, tokenText) {
    return this.typeToTokenToOperators.get(type).get(tokenText) || EMPTY_ARRAY;
  }

  followedBy(tokenText) {
    return this.followerMap.get(tokenText) || EMPTY_SET;
  }
}
</script>

<p>We can use the operator definitions and precedence relation to define a parser.</p>

<script class="visible" id="make-parser-defn">
function makeParser(opSet, canNest) {

  /**
   * Given a series of tokens with the structure produced by lex(),
   * returns a parse tree.
   *
   * For reference tokens have the following properties:
   *   tok:       the token text
   *   left:      index into the source whence came tok[0]
   *   right:     index into the source whence tok[tok.length-1] + 1
   *   synthetic: see recursive lexical structures
   *   mayInfix:  ditto
   *
   * A parse tree is a nested array structure where leaves are tokens.
   * In addition, each array has the following properties:
   *   op:    the operator
   *   left:  index into the source of the start of leftmost token contained
   *   right: index into the source of the end of rightmost token contained
   */
  return function parse(tokens) {
    if (typeof tokens === 'string' || !(Symbol.iterator in tokens)) {
      throw new TypeError('Expected iteratable over { tok, left, right }');
    }

    // We maintain a stack as we consume tokens left to right.
    // operatorStack[i+1] should be added as an operand to operatorStack[i]
    // unless an infix or postfix operator subsumes it.
    //
    // Each stack element has the following properties:
    //   op:          a member of the OperatorSet
    //   node:        the list of operands being built
    //   left, right: source position metadata
    const operatorStack = [{ op: rootOperator, node: [] }];

    /**
     * Truncate the stack by folding elements into their parents.
     * We do this lazily so that we can handle infix operations by
     * inserting them into the stack.
     *
     * After a call to commitTo(n) the length of the stack will be n.
     */
    function commitTo(depth) {
      let n = operatorStack.length;
      for (;n > depth; --n) {
        addNodeTo(operatorStack[n - 1], operatorStack[n - 2]);
      }
      operatorStack.length = n;
    }

    // Adds a node to a parent node
    function addNodeTo({ node, op, left, right }, parent) {
      // Store metadata with node.
      node.op = op;
      node.left = left;
      node.right = right;

      // Add the node to the parent.
      updatePositionMetadata(parent, left, right);
      parent.node.push(node);
    }

    // Adds a token to a node.
    function addTokenTo(token, el) {
      const { left, right } = token;
      el.node.push(token);
      updatePositionMetadata(el, left, right);
    }

    // Modify metadata to include code-units in the given range.
    function updatePositionMetadata(el, left, right) {
      el.left  = 'left' in el  ? Math.min(el.left,  left)  : left;
      el.right = 'right' in el ? Math.max(el.right, right) : right;
    }

    // We do some tricks to let us consume part of a token.
    // See angle bracket handling corner cases above:
    //     let a: Array<Array<number>>= [[]];
    let token = null;

    token_loop:
    for (let tokenIt = tokens[Symbol.iterator](), nextToken
         ;; token = nextToken) {
      nextToken = null;
      if (token === null) {
        let { value, done } = tokenIt.next();
        if (done) { break; }
        token = value;
      }
      // Now we've got a token.  Yay us!

      // The ordering in which we try strategies comes from a
      // preference to complete existing structures over
      // starting new structures.
      // This matters when a token might be interpretable as
      // *  both an infix operator or a ternary follower (':')
      // *  a prefix and postfix operator ('++', '--')
      // *  an infix and a prefix operator ('-', '+')
      // *  an infix operator and a close bracket ('>')

      const { tok, synthetic } = token;
      let mayInfix = token.mayInfix || !synthetic
      // See if tok might be part of a ternary or other operator.
      const follows = opSet.followedBy(tok);
      if (follows.size) {
        for (let i = operatorStack.length; --i >= 0;) {
          const el = operatorStack[i];
          if (needsCloseBracket(el)) {
            break;
          }
          const { op, node } = el;
          if (follows.has(op)) {
            let tokIndex = indexOfToken(node, op.tok);
            let maxFollowerSeen = -1;
            const fn = op.followers.length;
            // Figure out which followers we've consumed.
            for (let fi = 0; fi < fn; ++fi) {
              const follower = op.followers[fi];
              let ti = indexOfToken(node, follower, tokIndex + 1);
              if (ti >= 0) {
                maxFollowerSeen = fi;
                tokIndex = ti;
              }
            }
            // See if tok is a follower after the last consumed.
            const fip = op.followers.indexOf(tok, maxFollowerSeen + 1);
            if (fip >= 0) {
              commitTo(i + 1);
              addTokenTo(token, el);
              continue token_loop;
            }
          }
        }
      }

      // See if we can close an unclosed bracket operation.
      if (closeBrackets.has(tok) || tok[0] === '>') {
        const closeBracket = tok[0] === '>' ? '>' : tok;
        if (closeBrackets.has(closeBracket)) {
          for (let i = operatorStack.length; --i >= 0;) {
            const el = operatorStack[i];
            const partner = bracketPartners.get(el.op.tok);
            if (partner && closeBracket === partner && needsCloseBracket(el)) {
              // TODO: should probably also check that the open bracket
              // token's .synthetic === token.synthetic.
              commitTo(i + 1);
              let closeToken = token;
              if (tok !== closeBracket) {
                [ closeToken, nextToken ] =
                    splitToken(token, closeBracket.length);
                // Hack to let us find multiple close brackets in
                // tokens like ">>", ">>>", ">>=", ">>>=".
              }
              addTokenTo(closeToken, el);
              continue token_loop;
            }
          }
        }
      }

      const separatorsMatching = opSet.operators(SEPARATOR, tok);
      for (op of separatorsMatching) {
        let leftDepth = null;
        let rightDepth = null;
        const outerCandidate = { op, node: [] };
        const innerCandidate = { op, node: [] };
        addTokenTo(token, innerCandidate);
        for (let i = operatorStack.length; --i >= 0;) {
          const el = operatorStack[i];

          if (el.op === op) {
            // If we can continue an existing operation, do so.
            commitTo(i + 1);
            addTokenTo(token, el);
            continue token_loop;
          }

          // Maybe we have a separator without a left operand.
          if (canNest((index) => operatorStack[i - index], innerCandidate)) {
            rightDepth = i
          }

          if (needsCloseBracket(el)) { break }

          // Can we swap el into a new separator run as the left argument.
          if (i
              // Can candidate contain el?
              && canNest(
                (index) => index ? operatorStack[i - index] : outerCandidate,
                el)
              // Can el's existing parent contain candidate?
              && canNest(
                (index) => operatorStack[i - 1 - index],
                outerCandidate)) {
            leftDepth = i;
          }
        }
        if (leftDepth !== null) {
          const el = operatorStack[leftDepth];
          // Swap the existing element in as the left operand of a separator.
          commitTo(leftDepth + 1)
          addNodeTo(el, outerCandidate);
          addTokenTo(token, outerCandidate);
          operatorStack[leftDepth] = outerCandidate;
          continue token_loop;
        } else if (rightDepth !== null) {
          // Start a new operation that is missing a left operand.
          commitTo(rightDepth + 1)
          operatorStack.push(innerCandidate);
          continue token_loop;
        }
      }

      const prefixOperatorsMatching = opSet.operators(PREFIX, tok);
      if (mayInfix && prefixOperatorsMatching.length) {
        // Don't try as an infix operator if el is incomplete and tok could be a
        // prefix operator that would complete it.
        // When parsing
        //     x - -y
        // the second `-` might be interpreted as an infix operator or prefix.
        // If interpreted as an infix operator we'd go from a stack like
        //     INFIX "-" : (x) -
        //     ROOT      :
        // to
        //     INFIX "-" : ((x) -) -
        //     ROOT      :
        // where the incomplete binary operator is the left operand of the new
        // subtraction.
        // Eventually, when we process "y" and commit the stack we'd end up with
        // an expression like
        //     (x - ?) - y
        // This check makes sure that the second `-` is interpreted as a prefix
        // operator, so that the stack after processing "y" and before
        // committing looks like
        //     PREFIX "-": -(y)
        //     INFIX "-" : (x) -
        //     ROOT      : ()
        // which commits to
        //     ROOT      : ((x) - (- (y)))

        // We only check the top stack element, since any others would
        // presumably get an operand when the higher depth is committed.
        let topIndex = operatorStack.length - 1;
        const top = operatorStack[topIndex];
        if (needsOperand(top)) {
          for (const op of prefixOperatorsMatching) {
            const candidate = { op, node: [] };
            addTokenTo(token, candidate);
            if (canNest(
                  (index) => operatorStack[topIndex - index], candidate)) {
              mayInfix = false;
              break
            }
          }
        }
      }

      // See if the token continues an existing stack element.
      // For infix and postfix operators, we're looking for a safe place to
      // insert in the middle of the stack.
      // (Yes, pedants, this means our stack isn't a stack.)
      //
      // We insert just below the bottommost stack element that could serve
      // as a left operand according to canNest.
      //
      // We take care not to break out of unclosed brackets.
      if (mayInfix) {
        // synthetic '(' should not participate in function calling.
        // See lexical preparsing to handle backquoted strings.
        for (const opType of [POSTFIX, INFIX]) {
          for (const op of opSet.operators(opType, tok)) {
            let leftDepth = null;
            const candidate = { op, node: [] };
            for (let i = operatorStack.length; --i >= 0;) {
              const el = operatorStack[i];
              // Don't swap an open bracket into something while we're
              // looking for the close bracket.
              if (needsCloseBracket(el)) { break; }
              // Can we swap el into a new binary operator as the
              // left argument.
              if (
                  // Can candidate contain el?
                  canNest(
                    (index) => index ? operatorStack[i - index] : candidate,
                    el)
                  // Can el's existing parent contain candidate?
                  && i
                  && canNest(
                    (index) => operatorStack[i - 1 - index],
                    candidate)) {
                leftDepth = i;
              }
            }
            if (leftDepth !== null) {
              const el = operatorStack[leftDepth];
              commitTo(leftDepth + 1);
              addNodeTo(el, candidate);
              addTokenTo(token, candidate);
              operatorStack[leftDepth] = candidate;
              continue token_loop;
            }
          }
        }
      }

      // See if the token indicates that we need a new stack element.
      // Any prefix operator starts a new stack element, but first we may
      // pop any operations that cannot contain that prefix operator.
      for (const op of prefixOperatorsMatching) {
        const candidate = { op, node: [] };
        addTokenTo(token, candidate);
        // Commit stack elements that cannot contain candidate, so we
        // can start a new operand.
        for (let i = operatorStack.length; --i >= 0;) {
          const el = operatorStack[i];
          const { node, op: stackop } = el;
          if (stackop.type !== POSTFIX
              && canNest((index) => operatorStack[i - index], candidate)) {
            commitTo(i + 1);
            operatorStack.push(candidate);
            continue token_loop;
          }
          if (needsCloseBracket(el)) { break; }
        }
      }

      // No token left behind.
      // If no other strategy applied, treat the token as a parse tree leaf.
      const candidate = { op: notAnOperator, node: [] };
      addTokenTo(token, candidate);
      let closeTo = null;
      for (let i = operatorStack.length; --i >= 0;) {
        const el = operatorStack[i];
        if (el.op.type !== POSTFIX
            && canNest((index) => operatorStack[i - index], candidate)) {
          break;
        }
        closeTo = i;
      }
      if (closeTo !== null) {
        commitTo(closeTo);
      }

      let top = operatorStack[operatorStack.length - 1];
      // If we ever wanted to extend our precedence checks to
      // include a canTokenAppearIn(op, nonOperatorToken) or
      // canMergeInto(nonOperatorTokens, nonOperatorToken)
      // predicates, this is where they'd go.
      if (top.op === notAnOperator) {
        addTokenTo(token, top);
      } else {
        operatorStack.push(candidate);
      }
    }

    // After processing all tokens, fold stack elements into their parents.
    commitTo(1);
    // Then attach metadata to the root and return it.
    let { node, left, right } = operatorStack[0];
    node.op = rootOperator;
    node.left = left;
    node.right = right;
    if (node.length === 1 && Array.isArray(node[0])) {
      // If the root is an unnecessary grouping abstraction, discard it.
      node = node[0];
    }
    return node;
  };
}

/**
 * Given a token and an offset into its token text, returns two adjacent tokens
 * whose token texts concatenate to token's token text.
 */
function splitToken(token, offset) {
  const splitPos = Math.min(token.left + offset, token.right);
  return [
    {
      ...token,
      tok: token.tok.substring(0, offset),
      right: splitPos,
    },
    {
      ...token,
      tok: token.tok.substring(offset),
      left: splitPos,
    },
  ].map(x => x.tok ? x : null);
}

/**
 * True iff x is a leaf parse tree node.
 * Leaf tree nodes are structurally the same as tokens.
 */
function isLeafNode(x) {
  return typeof x.tok === 'string';
}

/**
 * Given a list of nodes/tokens, finds the index of the leaf/token
 * with the wanted token text.
 */
function indexOfToken(nodeList, want /* : string */, startIndex = 0) {
  for (let i = startIndex, n = nodeList.length; i < n; ++i) {
    if (nodeList[i].tok === want) {
      return i;
    }
  }
  return -1;
}
</script>

<p>Tests use these unless otherwise specified.</p>

<script class="visible">
const operatorSet = new ClosedOperatorSet(operators);
const parse = makeParser(operatorSet, canNest);
</script>

<h2 id="lexing">Lexing</h2>

<p>We've defined a parser that operates on a stream of tokens, but
have not yet defined the source of those tokens.  This lexer is not
interesting except to demonstrate strategies for dealing with
irregularities and recursive lexical constructs without entangling the
parser &amp; lexer.</p>

<p>Note: Readers may find it confusing when I use the term
&ldquo;context-free&rdquo; (CF) to refer specifically to the lexical
grammar instead of the language as a whole.  Some C-like languages
have simple lexical grammars but are not CF.  E.g., in C++ the parser
needs context about whether &ldquo;x&rdquo; is a type to decide
whether <code>x* y;</code> is a declaration of a pointer variable or an
application of <code>operator *</code>.  This kind of complication
does not mean that an input cannot be split into tokens with a CF
lexical grammar, even though you may need to do some tricks when
&ldquo;<code>&gt;&gt;</code>&rdquo; follows type parameters.)  See
also
<a href="http://trevorjim.com/c-and-cplusplus-are-not-context-free/">Trevor Jim</a>.</p>

<p>C-like languages' lexical grammars need not be <i>regular</i>,
meaning there need not exist a single regular expression that
partitions the input into tokens.  JavaScript and Perl give some ideas
of where common non-regularities arise; neither have either regular or
context-free lexical grammars; both require scannerless parsing.</p>

<p id="scannerless">It is possible to restructure the parser above to be
scannerless; where the parser above asks &ldquo;is the current token
an infix operator?&rdquo;, a scannerless parser would ask &ldquo;which,
if any, is the longest infix operator that is a prefix of the remaining
input and can nest here?&rdquo;.</p>

<p>
  We do not do that though, because non-CF lexical grammars defeat our
  goal of allowing simple analyzers to correctly segment fragments of
  code that start and end on token boundaries.
</p>

<p>So CF grammars meet our goals, but regular lexical grammars are
insufficient for commonly used, C-like languages.  Complications arise
when deciding whether &lsquo;/&rsquo; starts a division operator
(like <code>/</code> or <code>/=</code>) or a
<code>/regular-expression-literal/</code>.</p>

<p>Below is a lexer that recognizes
<code>/regular-expression-literals/</code> and
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">JavaScript-esque <code>`template ${ literals }`</code></a>.
It is CF but non-regular in two ways:</p>

<ul>
  <li>
    <p>When parsing a token starting with &lsquo;/&rsquo;</p>
    <ol>
      <li>If the token starts with <code>//</code> or <code>/*</code> then the
        current token is a comment token.</li>
      <li>Let <i>last</i> be the last significant (non-comment or whitespace) token.</li>
      <li>If <i>last</i> is a prefix operator, an infix operator, or an
        open bracket, then parse the current token as a regular expression.<br>
      <li>Else parse the current token as a division operator.</li>
    </ol>
    <p>This differs from JavaScript around expressions like <code>x = ++/regex/i.index</code>
      and <code>x++ /num/i</code> because some operators (++, --, +, -) are both infix/prefix
      and postfix operators.
      (The author believes this is not a source of confusion in practice,
      but has not measured).</p>
  </li>
  <li>The lexer keeps a stack of bits so it can tell whether a &lsquo;}&rsquo;
    is a regular source token or returns lexing to content of a JavaScript-esque
    template literal.</li>
</ul>

<script class="visible" id="lex-script">
// Identifiers and keywords start with a letter, underscore, dollar
// sign, non-ascii character, or unicode escape sequence.
const WORD_START = String.raw`(?:[_$a-zA-Z]|[^\x00-\x7F]|\\u[0-9a-fA-F]{4})`;
const WORD_CONTINUE = String.raw`(?:${ WORD_START }|[0-9])`;

const WORD_RE = new RegExp(`^${ WORD_START }${ WORD_CONTINUE }*$`);

/** A regex pattern that matches the input string literally. */
function regexEscape(x) {
  return x.replace(/[\W$]/g, '\\$&');
}

const allOperators = [...operators.map(x => x.tok), ...closeBrackets.keys()]
      .flat()
      // Keywords like `instanceof`, `else`, `new` handled as word tokens.
      .filter((x) => !WORD_RE.test(x))
      // Sort in reverse length order so RegExp matches longest possible.
      .sort((a, b) => b.length - a.length);
// Partition operators to allow for regexp/division operator disambiguation.
const nonDivOperators = allOperators.filter((x) => x[0] !== '/');
const divOperators =    allOperators.filter((x) => x[0] === '/');

// Matches ignorable tokens at start of input.
const ignorableTokens = new RegExp('^(?:' + [
  // White space.
  String.raw`[\t\n\r ]+`,
  // Line comment
  String.raw`//[^\n\r]*`,
  // Block comment
  String.raw`/[*](?:[^*]|[*]+(?![*/]))*(?:[*]/?)?`,
].join('|') + ')*');

// Matches a token whose interpretation does not depend on context.
const uncontroversialToken = new RegExp('^(?:' + [
  // Single quoted string
  String.raw`'(?:[^\n\r'\\]|\\(?:[^\n\r]|$))*'?`,
  // Double quoted string
  String.raw`"(?:[^\n\r"\\]|\\(?:[^\n\r]|$))*"?`,
  // Number
  String.raw`0[xX][0-9a-fA-F]+[g-zG-Z]*`,
  String.raw`[.][0-9]+(?:[eE][+\-]?[0-9]+)?[a-zA-Z]*`,
  String.raw`[0-9]+(?:[.][0-9]*)?(?:[eE][+\-]?[0-9]+)?[a-zA-Z]*`,
  // Non-division operator.
  ...nonDivOperators.map(regexEscape),
  // Identifier
  `@?${ WORD_START }${ WORD_CONTINUE }*`,
].join('|') + ')');

// Matches a division operator at the beginning of input.
const divToken = new RegExp(
  '^(?:' + divOperators.map(regexEscape).join('|') + ')');

// Matches a regular expression literal at the beginning of input.
const regexpToken = new RegExp(
  (() => {
    const notAComment = String.raw`(?![*/])`;
    const normalChar = String.raw`[^\n\r/\[\\]`;
    const esc = String.raw`\\(?:[^\n\r]|$)`;
    const charBlock  = String.raw`\[(?:[^\\\]]|${ esc })*(?:\]|$)`;
    const bodyElement = String.raw`(?:${ normalChar }|${ esc }|${ charBlock })`;
    const closeAndFlags = String.raw`(?:/[a-zA-Z]*)?`;

    return String.raw`^/${ notAComment }${ bodyElement }*${ closeAndFlags }`;
    // If you ever have to debug this regex, please know that I am deeply sorry.
  })()
);

// Matchs a chunk of a template literal not including the opening backquote.
const backquoteStringContent = new RegExp(
  String.raw`^(?:[^\`\\$]|[$](?![\{])|\\[\s\S]?)*`);

/**
 * Given a source text, produce a series of tokens.
 *
 * Tokens have the form { tok, left, right } where left and right are
 * indices into sourceText, and tok is a substring of sourceText
 * (modulo ambiguity caveat below).
 *
 * The tokens may be broken, for example, an unclosed string literal.
 * If a broken token had to be adjusted to avoid ambiguity, for example,
 * a / at end of input where a regular expression literal is expected,
 * then onLexError will be called and an unambiguous token returned.
 *
 * Comment and whitespace tokens do not appear in the output unless
 * emitIgnorable is true.
 */
function *lex(
  sourceText,
  {
    opSet = operatorSet,
    onLexError = () => {},
    emitIgnorable = false,
  } = {}) {
  sourceText = `${ sourceText }`;

  // We need to keep track of whether, after a '}', comes more `...` content.
  const doesCloseCurlyReenterString = [];
  // One token of lookbehind used to disambiguate '/'.
  let lastToken = ';';
  // If in a backquoted string, any prefix for the content token.
  let backquotedStringPrefix = null;
  // The number of characters from the start of sourcePosition to the left
  // of sourceText.
  let sourcePosition = 0;

  // Consume n characters from sourceText.
  function consume(n) {
    sourceText = sourceText.substring(n);
    sourcePosition += n;
  }

  while (sourceText) {
    // Handle the case where a prefix of sourceText is part of a `...` string
    // that started earlier.
    if (backquotedStringPrefix !== null) {
      let left = sourcePosition - backquotedStringPrefix.length;
      let [ content ] = backquoteStringContent.exec(sourceText);
      consume(content.length);
      if (sourceText[0] === '`') {
        content += '`';
        consume(1);
      } else if (sourceText[0] === '$' && sourceText[1] === '{') {
        content += '${';
        consume(2);
        doesCloseCurlyReenterString.push(true);
      } else {
        // Need to differentiate unclosed token like `${ stuff }
        // from close curly token outside a backquote string.
        onLexError(left, sourcePosition, 'Unterminated string');
        content += '`';
      }
      lastToken = backquotedStringPrefix + content;
      yield ({
        tok: lastToken,
        left,
        right: sourcePosition,
        __proto__: null });
      backquotedStringPrefix = null;
      continue;
    }

    // Consume any comment or whitespace tokens.
    const [ { length: nToIgnore } ] = ignorableTokens.exec(sourceText);
    if (nToIgnore) {
      if (emitIgnorable) {
        yield({
          tok: sourceText.substring(0, nToIgnore),
          left: sourcePosition,
          right: sourcePosition + nToIgnore,
          __proto__: null,
        });
      }
      consume(nToIgnore);
      if (!sourceText) { break; }
    }

    // Handle '}' that reenters `...` content.
    const c = sourceText[0];
    if (c === '}') {
      const depth = doesCloseCurlyReenterString.length;
      if (depth && doesCloseCurlyReenterString[depth - 1]) {
        backquotedStringPrefix = '';
        --doesCloseCurlyReenterString.length;
        // Leave } as part of backquote string content so that it is
        // differntiable, solely based on text content, from non-backquote
        // string content tokens.
        // Every backquote string token either starts or ends with a backquote
        // or ends with "${" and starts with "}".
        continue;
      }
    }

    const left = sourcePosition;

    // Use lastToken to disambiguate between RegExp literals and div operators.
    if (c === '/') {
      const isRegexp = Boolean(
        lastToken === ';'
        || opSet.operators(PREFIX, lastToken).length
        || opSet.operators(INFIX, lastToken).length
        || opSet.followedBy(lastToken).size);
      let [ token ] = (
        isRegexp
          ? regexpToken
          : divToken ).exec(sourceText);
      consume(token.length);
      if (isRegexp && token === '/' || token === '/=') {
        onLexError(left, sourcePosition, 'Untermined RegExp literal');
        token += '(?:)';
      }
      yield ({
        tok: lastToken = token,
        left,
        right: sourcePosition,
        __proto__: null,
      });
      continue;
    }

    // Reenter if we're entering a `...` string literal.
    if (c === '`') {
      backquotedStringPrefix = '`';
      consume(1);
      continue;
    }

    // Use the bug regular expression defined above to find one token
    // at the front of input.
    const match = uncontroversialToken.exec(sourceText);
    let token;
    if (match) {
      ([ token ] = match);
    } else {
      // Consume one character as a fallback.
      // This handles characters like '#' that are not part of any
      token = c;
    }
    consume(token.length);
    // Keep the curly bracket stack up-to-date.
    if (/[{]$/.test(token)) {
      doesCloseCurlyReenterString.push(false);
    } else if (/^[}]/.test(token) && doesCloseCurlyReenterString.length) {
      --doesCloseCurlyReenterString.length;
    }
    yield ({
      tok: lastToken = token,
      left,
      right: sourcePosition,
      __proto__: null,
    });
  }

  // Error channel notified when input ends where we expect more content.
  if (backquotedStringPrefix !== null || doesCloseCurlyReenterString.length) {
    const message = backquotedStringPrefix !== null
          || doesCloseCurlyReenterString[doesCloseCurlyReenterString.length - 1]
          ? 'Source ended inside string'
          : 'Source ended inside brackets'
    onLexError(sourcePosition, sourcePosition, message);
  }
}
</script>

<p>
  Our lexer works as expected on some sample inputs.  These tests
  show the series of tokens produced, with comment and whitespace
  tokens filtered out.
</p>

<script>
  tl(
    '{ foo(`a=${ a } b=${ b }`) }',
    [ '{', 'foo', '(', '`a=${', 'a', '} b=${', 'b', '}`', ')', '}']);
  tl(
    'a/b',
    [ 'a', '/', 'b']);
  tl(
    'a/b/i',
    [ 'a', '/', 'b', '/', 'i']);
  tl(
    'a=/b/i',
    [ 'a', '=', '/b/i']);
  tl(
    'a(/b/i)',
    [ 'a', '(', '/b/i', ')']);
  tl(
    'a/(b/i)',
    [ 'a', '/', '(', 'b', '/', 'i', ')']);
  tl(
    '/*a*//(b)/i/j/k',
    [ '/(b)/i', '/', 'j', '/', 'k']);
  tl(
    '/*a*//(b)/;/j/k',
    [ '/(b)/', ';', '/j/k']);
  tl(
    '/* only ignorable */ // tokens',
    []);
  tl(
    String.raw`[
      'strings', "strings", "more\t\"strings\"", "'", '"', "unterminated
    ]`,
    [
      '[',
      '\'strings\'', ',',
      '"strings"', ',',
      '"more\\t\\"strings\\""', ',',
      '"\'"', ',',
      '\'"\'', ',',
      '"unterminated',
      ']',
    ]);
  tl(
    '// line comment\nends',
    [ 'ends' ]);
  tl(
    '/* comments do not /* nest */ */',
    [
      '*',
      '/(?:)'  // A / where a RegExp is expected at end of input would be ambiguous.
    ],
    { hasLexErrors: true });
  tl(
    '/* numbers */ 0 .00001 123.456 1. 1e-1 6E23 1e+0 1L 4f 3.14159265e 1-1',
    [
      '0',
      '.00001',
      '123.456',
      '1.',
      '1e-1',
      '6E23',
      '1e+0',
      '1L',
      '4f',
      '3.14159265e',
      '1', '-', '1',
    ]
  );
</script>


<h3 id="before-lexing">Before lexing</h3>

<p>
  Before lexing, a source file needs to be converted from a stream of
  bytes to a stream of larger code-units.  Some recent languages
  have mandated UTF-8 as the way to do this.
</p>

<p>
  For example, the <a href="https://golang.org/ref/spec#Source_code_representation">Go
    specification</a> says:
</p>

<blockquote>
  <p>
    Source code is Unicode text encoded in UTF-8.
  </p>
</blockquote>

<p>
  Language-mandated encodings mean that there's no risk of different
  tools assuming different encodings for the same source files, and
  no inconsistently supplied command line flag hints.
</p>

<p>
  Some languages do more before lexing happens.  Java, and JavaScript,
  for example, both allow <code>\uABCD</code> to appear in both string
  literals and in identifier names.  Before UTF-8 had obviously won,
  this made it straightforward to convert a program to 7-bit ASCII for
  easy interchange; escape any codepoint &ge; 128 using
  &ldquo;\u&rdquo; syntax and if there're an odd number of
  &lsquo;\&rsquo; preceding, remove one.  (This no longer works for
  JavaScript because the raw content of tagged template literals is
  observable.)
</p>

<pre class="prettyprint">
// These two are equvalent in both Java and JavaScript.
&#x3c0;      = 3.14159D;
\u03c0 = 3.14159D;
</pre>

<p>
  Java, unlike JavaScript, does this
  <a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-3.html#jls-3.2"
     >before the lexer</a> has a chance to match quotes though.
</p>

<pre class="prettyprint">
char doubleQuoteChar = '\u0022';
doubleQuoteString = "\u0022"; // Syntax error because equivalent to:
doubleQuoteString = "&quot;";
</pre>

<p>
  Encodable string delimiters violate developers&apos; intuitions
  about the boundaries between programming language tokens and tokens
  in the embedded language that describes the content of the string
  values in question.
</p>

<p>
  This oddity of Java can be used to hide code from static analyzers and
  to make silly programs that work in multiple languages, but adds no
  expressive power or clarity to Java.
</p>

<pre class="prettyprint">
// \u000a       public class C {
// \u000a         static void log(String s) { System.out.println(s); }
// \u000a         public static void main(String[] argv) {
/* \u002a/// */     let {log} = console;
                    log(
                      "Java"
/* \u002a/// */       + "Script"
                    );
// \u000a       } }

// This confuses tools.
// E.g., in Emacs's Java-mode, only the JavaScript for this program
// shows as non-comment text.
</pre>

<p>
  Most C and C++ programmers go their entire career without ever
  intentionally using
  <a href="https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C">digraphs
    or trigraphs</a> which are expanded by the C preprocessor.
</p>

<pre class="prettyprint lang-c">
// These two were equivalent until recent versions of C++.
  { x =   ~y;   }
??&lt; x = ??-y; ??&gt;

// A source of hard-to-diagnose bugs when '??' appears in a string literal.
// What does this do?
cout << &quot;??/&quot;; // &quot;;
</pre>

<p>
  Complex, language-specific transformations before lexing are sources
  of hard-to-diagnose bugs when tools, code generators, or programmers
  forget about them.  For languages that don&apos;t have legacy EBCDIC
  code, I&apos;ve yet to see a case where complex decoding logic could
  not be delayed until after processing high-level structure like
  matching of quotes and brackets.
</p>


<h3 id="token-preparsing">Token preparsing</h3>

<p>
  Unfortunately, our parser can&apos;t deal with complex constructs like
  <code>`staticText ${ dynamicValue } etc.`</code> that span multiple
  tokens.
</p>

<script>
  tl('`staticText ${ dynamicValue } etc.`',
     ['`staticText ${', 'dynamicValue', '} etc.`']);
</script>

<p>
  We could build knowledge of this into the parser, but that would
  defeat the goal of having few, simple rules, and moving most of the
  understanding into the language-specific parse tree &rarr; AST
  transform.
</p>

<p>
  Instead, we transform the token stream between the lexer and the
  parser by adding synthetic tokens.  This keeps knowledge about
  complex lexical constructs in the pre-parse phases.
</p>

<table>
  <tr><th>Before</th><td> <td><code>`staticText ${</code></td>
    <td> <td><code>dynamicValue</code><td> <td><code>} etc.`</code><td> </tr>
  <tr><th>After </th><td>(<td><code>`staticText ${</code></td>
    <td>(<td><code>dynamicValue</code><td>)<td><code>} etc.`</code><td>)</tr>
</table>

<p>
  The added parentheses have the effect of ensuring that the whole
  string is grouped as one construct, and that expressions inside holes
  (<code>${...}</code>) are self-contained.  Open parenthesis is overloaded
  in most C-like languages to mean (grouping, function call, type cast)
  so we take care that the synthesized parentheses around holes
  are not interpreted as INFIX operations.
</p>

<script class="visible">
/**
 * Insert synthetic tokens into a token stream to ensure that recursive
 * lexial constructs are wrapped in parentheses to establish a separate
 * scope for precedence operations.
 */
function *preparseTokens(tokens) {
  for (const token of tokens) {
    const { tok } = token;
    const isBackquotedStringSection = /(?:.[$][{]|`)$/.test(tok);
    if (isBackquotedStringSection) {
      const startsStr = tok[0] === '`';
      yield {
        tok: (startsStr ? '(' : ')'),
        left: token.left,
        right: token.left,
        synthetic: true,
        // Synthetic parentheses around hole expressions should not
        // be interpreted as the parentheses around function call
        // arguments.
        mayInfix: startsStr,
      };
    }
    yield token;
    if (isBackquotedStringSection) {
      yield {
        tok: (tok[tok.length - 1] === '{' ? '(' : ')'),
        left: token.right,
        right: token.right,
        synthetic: true,
        mayInfix: false,
      };
    }
  }
}
</script>

<script id="template-literal-example">
  tl('`staticText ${ dynamicValue } etc.`',
     [ '(', '`staticText ${', '(', 'dynamicValue', ')', '} etc.`', ')' ],
     { preparse: preparseTokens });
</script>

<p>
  We can see that this parses sensibly, even when there&apos;s an errant
  &lsquo;;&rsquo; in an expression that fills a hole, and that the
  parentheses around holes do not participate in function application.
</p>

<script>
  tp(
    'f`__${ x; }__${ y = z() }__` + "str";',
    [
      [
        [
          [ 'f' ],
          '(',
          [ '`__${' ],
          [
            '(',  // Grouping, not function application.
            [
              [ 'x' ],
              // Semicolon does not drop out to statement context.
              ';'
            ],
            ')'
          ],
          [ '}__${' ],
          [
            '(',
            [
              [ 'y' ],
              // Low precedence assignment operator does not dop out of
              // higher precedence '+' operator.
              '=',
              [
                [ 'z' ],
                '(',
                ')'
              ],
            ],
            ')'
          ],
          [
            '}__`'
          ],
          ')'
        ],
        '+',
        [ '"str"' ]
      ],
      ';'
    ]
  );
</script>


<h2 id="asi">Automatic Semicolon Insertion (ASI)</h2>

<p>Some C-like languages automatically insert semicolons.</p>

<pre class="prettyprint">
let x = 1    /* ; */
let y = 2    // Not here
        + x  /* ; */
</pre>

<p>
  This may make writing code easier, requiring fewer keystrokes and
  getting rid of common error messages about missing semicolons.  ASI
  may be a net positive for authors, but in all languages that do it
  is a source of uncommon, but subtle bugs.  Whether it is better for
  readers is unclear; does careful code review require correctly
  predicting where semicolons are inserted.
</p>

<p>
  This section discusses different varieties of semicolon insertion
  and how they affect operator precedence parsing.  Later,
  <a href="#suggestions">suggestions</a> provides concrete advice.
  The parser introduced above does not do semicolon insertion.
</p>

<h3 id="syntactic-asi">Syntactic ASI</h3>
<p>
  ASI can be deeply entangled with parsing:
</p>

<ul>
  <li><a href="https://tc39.es/ecma262/#sec-automatic-semicolon-insertion">JavaScript</a>&apos;s
    ASI relies on exhaustive parsing to know when an insertion
    would not prevent expanding the current statement:
    <blockquote>
      <p>When, &hellip;, a token (called the offending token) is
        encountered that is not allowed by any production of the
        grammar, then a semicolon is automatically inserted before the
        offending token if &hellip;</p>
    </blockquote>
  <li>
    Details on
    <a href="https://kotlinlang.org/docs/reference/coding-conventions.html#semicolons">Kotlin&apos;s ASI</a>
    are hard to come by.
    <a href="https://android.jlelse.eu/why-i-missed-semi-colons-today-e2fb136f58e5">Failure reports</a>
    suggest that it is syntactic, but that, unlike JavaScript, it
    biases towards inserting.  Whereas JavaScript rarely inserts
    when the first token on the next non-blank line could continue
    the current statement, Kotlin seems to insert a semicolon at any
    linebreak that wouldn&apos;t invalidate the preceding statement.
    This avoids the need for &ldquo;restricted productions&rdquo;
    (productions in which line terminators are forbidden) since all
    productions are effectively restricted.
</ul>

<p>
  This operator precedence scheme allows two non-operator tokens to
  appear adjacent: <code>int x</code>.  An attempt to build ASI into an
  operator precedence parser would need to design the language to avoid
  adjacent words or explicitly handle this via some kind of adjacency
  operator, so that the parser could elect to insert a semicolon when
  the current token would require popping the stack past semicolon&apos;s
  precedence level, and a postfix semicolon could accept the lowest
  precedence stack element that has precedence greater than semicolon.
</p>

<h3 id="lexical-asi">Lexical ASI</h3>
<p>
  Alternatively, ASI can be based on lexical analysis before parsing
  starts, which would allow it to be done during
  <a href="#token-preparsing">token preparsing</a> which would allow
  ASI without entangling the parser:
</p>

<ul>
  <li><a href="https://golang.org/ref/spec#Semicolons">Go</a>:
    <blockquote>
      <p>a semicolon is automatically inserted into the token stream
        immediately after a line&apos;s final token if that token is
        &hellip;</p>
    </blockquote>
  <li><a href="http://jittakal.blogspot.com/2012/07/scala-rules-of-semicolon-inference.html">Scala</a>:
    <blockquote>
      <p>A line ending is treated as a semicolon unless one of the
      following conditions is true: <i>[predicates about the top of
      the bracket stack, or next/last token]</i></p>
    </blockquote>
</ul>

<h3 id="asi-affects-tooling">Effect of ASI on Tooling</h3>

<p>
  Simple operations like moving tokens from one line to another to
  split overly long lines becomes more complicated when you need to
  ensure that the compiler won&apos;t differently insert semicolons.  For
  example, in JavaScript ASI can cause two similar looking programs to
  be interpreted quite differently
  (see also <a href="https://tc39.es/ecma262/#sec-examples-of-automatic-semicolon-insertion">Ecma262 &para; 11.9.2</a>):
</p>

<pre class="prettyprint">
for (let i = 0; i &lt; 10; i++) {
  f(i);
}
//        &darr;
for (let i = 0; i &lt; 10; i
     ++) {
  f(i);
}
// SyntaxError.  Per JavaScript&apos;s ASI rules `++` cannot be separated
// from its operand by a line break.


longName = i++
f()
//        &darr;
longName = i
++
f()
// Loud semantic change.  Second equivalent to `longName=i;++(f());`


function f(longName) {
  return longName()
}
//        &darr;
function f(longName) {
  return
    longName()
}
// Silent semantic change.  Call never happens.  Returns undefined
</pre>

<p>
  With ASI, a developer using a generic editor function like Emacs&apos;s
  <i>fill-paragraph</i> (M-q) without a JavaScript-specific mode hook
  runs a risk of introducing subtle semantic changes to code.
  This is subideal.
</p>

<h3 id="tool-based-asi">Tool-based ASI</h3>
<p>
  Another option (unimplemented in any language to the best of the
  authors&apos; knowledge) is to do ASI but not in a way that&apos;s
  invisible to authors and readers.
</p>

<p>
  Much of the debate about ASI can be boiled down to two claims
  which seem mutually contradictory but are actually reconcilable:
</p>

<ul>
  <li>The language should incorporate ASI to make it easier for
    authors (especially novices) to produce programs, and to reduce
    cognitive load for casual readers.</li>
  <li>The language&apos;s compiler/interpreter should not perform ASI
    since it is a source of subtle bugs and careful reading of code is
    difficult when readers have to predict where semicolons are
    inserted.</li>
</ul>

<p id="tool-inserted-semicolons">
  Language designers could specify how ASI should be done, commit to
  taking ASI into account when considering backwards compatibility,
  but leave the actual insertion to developer tools.
</p>

<ul>
  <li>
    IDEs could perform ASI as developers type, thus relieving the
    author of the burden of typing semicolons, but making them
    explicit in the source text.
  </li>
  <li>
    Code syntax highlighters could de-emphasize (via lower-contrast
    coloring) semicolons that would be inserted by such hooks were
    they not present, reducing the cognitive burden on readers
    concerned with intent over semantics.
  </li>
  <li>
    Additionally, the compiler/interpreter could do ASI but then
    reqort a fatal error if any semicolons were actually inserted.
    Developers who uses inserting editors should never encounter one
    of these errors, but incorrigible Notepad users would have to
    produce output that would not change if loaded into an inserting
    editor and immediately saved.
  </li>
</ul>

<p>
  To demonstrate this, here&apos;s a simple lexical semicolon inserter.
</p>

<script class="visible">
/**
 * Given a stream of tokens, including ignorable tokens,
 * a stream of tokens.
 */
function *insertSemicolons(tokens) {
  const pending = [];
  const stillOpen = [];
  let lastSignificant = ';';  // Don't insert a semi at start of file
  for (const token of tokens) {
    const { tok } = token;
    const isIgnorable = ignorableTokens.exec(tok)[0].length !== 0;
    if (openBrackets.has(tok)) {
      stillOpen.push(tok);
    }
    if (closeBrackets.has(tok) && stillOpen.length) {
      --stillOpen.length;
    }
    if (pending.length) {
      if (isIgnorable) {
        pending.push(token);
        continue;
      } else {
        // Don't insert before an infix or postfix operator.
        if (!operatorSet.operators(INFIX, tok).length
            && !operatorSet.operators(POSTFIX, tok).length
            && !closeBrackets.has(tok)) {
	  let { left } = pending[0];
          yield {
            tok: ';',
            left,
            right: left,
          };
        }
        // Replay pending
        for (const token of pending) {
          yield token;
        }
        pending.length = 0;
      }
    }
    if (isIgnorable && /[\r\n]/.test(tok)) {
      // tok contains a line break.  As in JavaScript, a
      // /*...*/ comment with a line terminator char starts
      // a new line, but a multi-line string literal does not.
      if (!(stillOpen.length
            // Only insert inside curly blocks.
            && stillOpen[stillOpen.length - 1] !== '{')) {
        // Don't insert after an infix or prefix operator.
        if (!operatorSet.operators(INFIX, lastSignificant).length
            && !operatorSet.operators(PREFIX, lastSignificant).length
            && lastSignificant !== ';') {
          // By pushing onto pending, we delay a decision about
          // whether to insert a semicolon before this token.
          pending.push(token);
          // TODO: Don't insert after a malformed token
          // like an unclosed string or regex literal.
          continue;
        }
      }
    }
    if (!isIgnorable) {
      lastSignificant = tok;
    }
    yield token;
  }
  for (const token of pending) {
    yield token;
  }
}
</script>

<textarea id="asi-demo" cols=40 rows=6>let a = 1</textarea>

<script>
// When the user types in the textarea, try inserting semicolons.
(function () {
  const ta = document.getElementById('asi-demo');
  ta.onkeypress = () => setTimeout(doAsi);

  function doAsi() {
    const { selectionStart, selectionEnd, value } = ta;

    const valueBeforeCursor = value.substring(0, selectionEnd);
    const valueAfterCursor = value.substring(selectionEnd);

    const tokens = lex(valueBeforeCursor, { emitIgnorable: true });
    let newSelectionStart = selectionStart;
    let newSelectionEnd = selectionEnd;
    let newValue = '';
    for (const { tok, left, right } of insertSemicolons(tokens)) {
      if (left === right && tok === ';') {
        if (newValue.length <= newSelectionStart) {
          ++newSelectionStart;
        }
        if (newValue.length <= newSelectionEnd) {
          ++newSelectionEnd;
        }
      }
      newValue += tok;
    }
    newValue += valueAfterCursor;

    ta.value = newValue;
    ta.selectionStart = newSelectionStart;
    ta.selectionEnd = newSelectionEnd;
  }
})();
</script>

<h2 id="custom-expression-operators">Custom Expression Operators</h2>

<p><a href="https://docs.scala-lang.org/tour/operators.html#precedence">Scala</a>
shows one way of providing for user-defined infix expression operators.</p>

<blockquote>
  <p>Any method with a single parameter can be used as an infix operator.</p>
  &hellip;
  <p>When an expression uses multiple operators, the operators are
  evaluated based on the priority of the first character: &hellip;</p>
</blockquote>

<p>
  It&apos;s unsurprising that operation precedence parsers can handle
  user defined operators with different precedences.
</p>

<script class="visible">
const scalaesqueOperatorSet =
  new class ScalaesqueOperatorSet extends OperatorSet {
    constructor(fallbackOperatorSet) {
      super();
      this.fallbackOperatorSet = fallbackOperatorSet;
      this.customOperatorTable = new Map();
    }

    operators(type, tokenText) {
      const builtin = this.fallbackOperatorSet.operators(type, tokenText);
      if (type === INFIX && !builtin.length) {
        let custom = this.customOperatorTable.get(tokenText) || null;
        if (!custom) {
          // Per scala docs (docs.scala-lang.org/tour/operators.html#precedence)
          // > When an expression uses multiple operators, the operators
          // > are evaluated based on the priority of the first character
          for (const withFirstChar
               of this.fallbackOperatorSet.operators(type, tokenText[0])) {
            if (!withFirstChar.closer) {
              custom = { ...withFirstChar, tok: tokenText };
              this.customOperatorTable.set(tokenText, custom);
              break;
            }
          }
        }
        return custom ? [custom] : EMPTY_ARRAY;
      }
      return builtin;
    }

    followedBy(tokenText) {
      return this.fallbackOperatorSet.followedBy(tokenText);
    }
  }(operatorSet);

const scalaesqueParser = makeParser(scalaesqueOperatorSet, canNest);
</script>

<p>
  Now, user code can use an operator not defined above like
  &lsquo;<code>&lt;=&gt;</code>&rsquo; (trinary comparison in Perl)
  with precedence similar to &lsquo;<code>&lt;</code>&rsquo;:
</p>

<script>
  tp(
    'for (val a = 1; a + b <=> c * d +. e; ++a) { doTheThing(a) }',
    [
      [
        [ "for" ],
        "(",
        [
          [
            [ "val", "a" ],
            "=",
            [ "1" ]
          ],
          ";",
          [
            [
              [ "a" ],
              "+",
              [ "b" ]
            ],
            "<=>",
            [
              [
                [ "c" ],
                "*",
                [ "d" ]
              ],
              "+.",
              [ "e" ]
            ]
          ],
          ";",
          [
            "++",
            [ "a" ]
          ],
        ],
        ")"
      ],
      "{",
      [
        [ "doTheThing" ],
        "(",
        [ "a" ],
        ")"
      ],
      "}"
    ],
    {
      /**
       * A toy lexer that classifies each character as one of
       * (space, word, punctuation) and breaks into maximal
       * runs of each.  Does not handle comments or numbers
       * with fractions/signed exponents.
       */
      lexFn: function *splitOnBreaksAndSpaces(s) {
        const n = s.length;
        let lastCharType = ' ';
        let left = 0;
        for (let i = 0; i <= n; ++i) {
          const c = i < n ? s[i] : ' ';
          let charType = ' ';
          if (c > ' ') {
            charType = /\w/.test(c) ? 'a' : ';';
          }
          if (charType !== lastCharType) {
            if (lastCharType !== ' ') {
              yield { tok: s.substring(left, i), left, right: i };
            }
            left = i;
            lastCharType = charType;
          }
        }
      },
      parseFn: scalaesqueParser,
    });
</script>

<p>
  This requires some changed to lexing since our stock lexer splits
  &lsquo;<code>&lt;=&gt;</code>&rsquo; into two tokens:
  &lsquo;<code>&lt;=</code>&rsquo; and &lsquo;<code>&gt;</code>&rsquo;.
  The testcase above uses a lexer that simply splits on word breaks and spaces.
</p>

<p>
  One downside is that custom operators require developers to use more
  whitespace even in code that does not use custom operators.  This
  limitation arises because there is no closed set of punctuation
  strings that lets us split, for example &ldquo;<code>x*-y</code>&rdquo;
  into &ldquo;<code>x * -y</code>&rdquo; because
  &ldquo;<code>*-</code>&rdquo; could be a user defined operator.  C
  already has this problem to a small degree because
  &ldquo;<code>x--y</code>&rdquo; is not the same as
  &ldquo;<code>x - -y</code>&rdquo;, but developers typically write
  &ldquo;<code>x+y</code>&rdquo; instead of subtracting a negated
  value, so the fact that &lsquo;<code>++</code>&rsquo; and
  &lsquo;<code>--</code>&rsquo; are unsplittable by context-free
  lexers does not, in practice, confuse C authors.
</p>

<h2 id="well-formedness">Well-formedness</h2>

<p>
  These tests show some common ways a parse tree may fail some generic
  well-formedness checks, and in the process catalogue some common
  kinds of problematic inputs.
  Red <span class="problem-tokens">wiggly</span> underlines show
  tokens that participate in a malformed subtree.  Click the expando
  to see the error messages.
</p>

<ul>
  <li>A partial token like
    <script>
      twf(
        "s = 'no close quote",
        {
          parseTree: [ [ 's' ], '=', [ '\'no close quote' ] ],
          problems:  [ { left: 4, right: 19, message: 'Malformed token' } ],
        }
      );
      twf(
        '"ends with escape\\"',
        {
          parseTree: [ '"ends with escape\\"' ],
          problems:  [ { left: 0, right: 19, message: 'Malformed token' } ],
        }
      );
      twf(
        '"ends in escape\\',
        {
          parseTree: [ '"ends in escape\\' ],
          problems:  [ { left: 0, right: 16, message: 'Malformed token' } ],
        }
      );
      twf(
        '"invalid escape: \\x \\xA "',
        {
          parseTree: [ '"invalid escape: \\x \\xA "' ],
          problems:  [ { left: 0, right: 25, message: 'Malformed token' } ],
        }
      );
      twf(
        '/regex missing close',
        {
          parseTree: [ '/regex missing close' ],
          problems:  [ { left: 0, right: 20, message: 'Malformed token' } ],
        }
      );
      twf(
        '/* ambiguous partial regex */ /',
        {
          parseTree: [ '/(?:)' ],
          problems:  [
            { left: 30, right: 31, message: 'Untermined RegExp literal' },
            { left: 30, right: 31, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '/regex ends in [charblock',
        {
          parseTree: [ '/regex ends in [charblock' ],
          problems:  [
            { left: 0, right: 25, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '/* an unclosed comment',
        {
          parseTree: [],
          problems:  [
            { left: 0, right: 22, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '/* an unclosed comment *',
        {
          parseTree: [],
          problems:  [
            { left: 0, right: 24, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '`unclosed backquoted string',
        {
          parseTree: [ '(', [ '`unclosed backquoted string`' ], ')' ],
          problems:  [
            { left: 0, right: 27, message: 'Unterminated string' },
          ],
        }
      );
      twf(
        '`unclosed ${ hole',
        {
          parseTree: [
            '(',
            [ '`unclosed ${' ],
            [
              '(',
              [ 'hole' ],
            ],
          ],
          problems:  [
            { left: 17, right: 17, message: 'Source ended inside string' },
            { left: 0,  right: 17, message: 'Missing close bracket' },
            { left: 12, right: 17, message: 'Missing close bracket' },
          ],
        }
      );
    </script>
    <span id="nfc-test"><script>
      twf(
        '\u0065\u0301 == \u00e9',
        {
          parseTree: [
            [ '\u0065\u0301' ],
            '==',
            [ '\u00e9' ],
          ],
          problems: [
            {
              left: 0, right: 2,
              message: 'Unnormalized identifier `\u0065\u0301`: U+65 != U+e9 @ 0',
            },
          ],
        }
      );
      twf(
        '\\u0065\\u0301 == \\u00e9',
        {
          parseTree: [
            [ '\\u0065\\u0301' ],
            '==',
            [ '\\u00e9' ],
          ],
          problems: [
            {
              left: 0, right: 12,
              message: 'Unnormalized identifier `\u0065\u0301`: U+65 != U+e9 @ 0',
            },
          ],
        }
      );
    </script></span>
  </li>
  <li>
    An illegal token.
    <script>
      twf(
        '0129 // bad octal',
        {
          parseTree: [ '0129' ],
          problems:  [
            { left: 0, right: 4, message: 'Malformed token' },
          ],
        }
      );
      twf(
        '0XabcdUL, 0XabcdWOT',
        {
          parseTree: [
            [ '0XabcdUL' ],
            ',',
            [ '0XabcdWOT' ],
          ],
          problems:  [
            { left: 10, right: 19, message: 'Malformed token' },
          ]
        }
      );
    </script>
  </li>
  <li>A missing token.
    <script>
      twf(
        'f( // no close parenthesis',
        {
          parseTree: [
            [ 'f' ],
            '(',
          ],
          problems:  [
            { left: 0, right: 2, message: 'Missing close bracket' },
          ],
        }
      );
      twf(
        'if (b) { blocks_balanced( } else { but_parens_not }',
        {
          parseTree: [
            [
              [
                [ 'if' ],
                '(',
                [ 'b' ],
                ')',
              ],
              '{',
              [
                [ 'blocks_balanced' ],
                '(',
              ],
              '}',
            ],
            'else',
            [
              '{',
              [ 'but_parens_not' ],
              '}',
            ]
          ],
          problems: [
            { left: 9, right: 25, message: 'Missing close bracket' },
          ]
        }
      );
      twf(
        '{ statement; // missing close brace',
        {
          parseTree: [
            '{',
            [
              [ 'statement' ],
              ';'
            ],
          ],
          problems:  [
            { left: 35, right: 35, message: 'Source ended inside brackets' },
            { left: 0,  right: 12, message: 'Missing close bracket' },
          ],
        }
      );
      twf(
        'if (/* missing left operand */ || x) {}',
        {
          parseTree: [
            [
              [ 'if' ],
              '(',
              [
                '||',
                'x'
              ],
              ')',
            ],
            '{',
            '}',
          ],
          problems:  [
            { left: 31, right: 35 /* or 33 */, message: 'Operator || missing left argument' },
          ],
        }
      );
    </script>
  </li>
  <li>A missing construct.
    <script>
      twf(
        'do {} while',
        {
          parseTree: [
            [
              'do',
              [
                '{',
                '}',
              ],
            ],
            'while',
          ],
          problems:  [
            { left: 0, right: 11, message: 'Missing operand' },
          ],
        }
      );
      twf(
        '++ /* no operand */;',
        {
          parseTree: [
            [
              '++',
            ],
            ';',
          ],
          problems:  [
            { left: 0, right: 2, message: 'Missing operand' },
          ],
        }
      );
      twf(
        'x. + ;',
        {
          parseTree: [
            [
              [
                ['x'],
                '.',
              ],
              '+',
            ],
            ';',
          ],
          problems:  [
            { left: 0, right: 4, message: 'Missing operand' },
            { left: 0, right: 2, message: 'Missing operand' },
          ],
        }
      );
      twf(
        'x = ternary ? option0;',
        {
          parseTree: [
            [
              [ 'x' ],
              '=',
              [
                [ 'ternary' ],
                '?',
                [ 'option0' ],
              ],
            ],
            ';',
          ],
          problems:  [
            { left: 4, right: 21, message: 'Expected \':\'' },
          ],
        }
      );
      twf(
        'x = ternary ? option0 :;',
        {
          parseTree: [
            [
              [ 'x' ],
              '=',
              [
                [ 'ternary' ],
                '?',
                [ 'option0' ],
                ':',
              ],
            ],
            ';',
          ],
          problems:  [
            { left: 4, right: 23, message: 'Expected operand after \':\'' },
          ],
        }
      );
      twf(
        'statement_label: /* no statement */',
        {
          parseTree: [
            [ 'statement_label' ],
            ':',
          ],
          problems:  [
            { left: 0, right: 16, message: 'Missing operand' },
          ],
        }
      );
    </script>
  </li>
  <li>Extra tokens
    <script>
      twf(
        '{ } }',
        {
          parseTree: [
            [ '{', '}' ],
            [ '}' ],
          ],
          problems:  [
            { left: 4, right: 5, message: 'Unmatched close bracket' },
          ],
        }
      );
    </script>
  </li>
  <li>
    Things that aren&apos;t recognized as errors before the AST pass but
    which could be
    <script>
      twf(
        '`empty hole ${ }`',
        {
          parseTree: [
            '(',
            [ '`empty hole ${' ],
            [
              '(',
              ')',
            ],
            [ '}`' ],
            ')',
          ],
          problems:  [],
        }
      );
      twf(
        'while (cond) // missing block',
        {
          parseTree: [
            [ 'while' ],
            '(',
            [ 'cond' ],
            ')',
          ],
          problems:  [],
        }
      );
      twf(
        'while /* no condition */ {}',
        {
          parseTree: [
            [ 'while' ],
            '{',
            '}',
          ],
          problems:  [],
        }
      );
      twf(
        'array[/* no index */]',
        {
          parseTree: [
            [ 'array' ],
            '[',
            ']',
          ],
          problems:  [],
        }
      );
    </script>
  </li>
</ul>

<script class="visible">
/**
 * True if input is a well-formed token.
 *
 * This is advisory.  The definition of well-formedness is likely
 * more language specific than the overly-inclusive parser and lexer
 * defined above.
 *
 * This is sufficient for the output from lex, but not for
 * programattically generated tokens.  For example, it does not check
 * that line comments do not have embedded newlines or that block
 * comments do not embed "*\/".
 */
function isWellformedToken(tok) {
  return wellformedTokenPattern.test(tok);
}

/**
 * Given a parse tree and the operator set used to parse it,
 * returns an array of problems found.
 * An empty result indicates no problems.
 */
function checkParseTree(parseTree, { opSet = operatorSet } = {}) {
  const problems = [];
  walk(parseTree);
  return problems;

  function walk(pt) {
    const { op, left, right } = pt;
    if (!op) {
      problems.push({ left, right, message: 'Missing op metadata' });
    }

    switch (op.type) {
    case INFIX:
      if (op.closer && openBracketCount({ node: pt, op }, -1) !== 0) {
        problems.push({ left, right, message: 'Missing close bracket' });
      } else if (pt.length < 3) {
        problems.push({ left, right, message: 'Missing operand' });
      }
      if (op.followers) {
        let followerIndex = 0;
        for (let i = 2, n = pt.length; i < n; ++i) {
          const follower = op.followers[followerIndex];
          if (isLeafNode(pt[i]) && pt[i].tok === follower) {
            ++followerIndex;
            if (i + 1 === n || isLeafNode(pt[i + 1])) {
              const message = `Expected operand after '${ follower }'`;
              problems.push({ left, right, message });
              followerIndex = op.followers.length;
              break;
            }
          }
        }
        if (followerIndex < op.followers.length) {
          problems.push({
            left,
            right,
            message: `Expected '${ op.followers[followerIndex] }'`
          });
        }
      }
      break;
    case PREFIX:
      if (op.closer && openBracketCount({ node: pt, op }, -1) !== 0) {
        problems.push({ left, right, message: 'Missing close bracket' });
      }
      if (pt.length === 1 && op.tok !== 'default' && op.tok !== 'return') {
        problems.push({ left, right, message: 'Missing operand' });
      }
      break;
    case POSTFIX:
      if (pt.length === 1) {
        problems.push({ left, right, message: 'Missing operand' });
      }
      break;
    case SEPARATOR:
      break;
    case TOKEN:
      for (const { tok: el } of pt) {
        if (opSet.operators(INFIX, el).length
            || opSet.operators(POSTFIX, el).length) {
          if (!opSet.operators(PREFIX, el).length
              && el !== 'while' && el !== ';') {
            const message = `Operator ${ el } missing left argument`;
            problems.push({ left, right, message });
          }
        } else if (closeBrackets.has(el)) {
          problems.push({ left, right, message: `Unmatched close bracket` });
        }
      }
      break;
    default:
      problems.push({ left, right, message: `Unrecognized type ${ op.type }` });
      break;
    }

    for (const el of pt) {
      if (isLeafNode(el)) {
        if (!isWellformedToken(el.tok)) {
          problems.push({ left, right, message: 'Malformed token' });
        } else if (WORD_RE.test(el.tok)) {
          // Require NFC for identifiers.
          const decoded = el.tok.replace(
            /\\u([0-9A-Fa-f]{4})/g,
            (_, hex) => String.fromCharCode(parseInt(hex, 16)));
          const normalized = decoded.normalize('NFC');
          if (decoded !== normalized) {
            const cpl = commonPrefixLength(decoded, normalized);
            const message = `Unnormalized identifier \`${ decoded }\`: ${
              formatCodepointAt(decoded, cpl)
            } != ${
              formatCodepointAt(normalized, cpl)
            } @ ${ cpl }`;
            problems.push({ left, right, message });
          }
        }
      } else {
        walk(el);
      }
    }
  }
}

const wellformedTokenPattern = new RegExp('^(?:' + [
  // Strings
  String.raw`'(?:[^'\\]|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\['"\`\\btrnf])*'`,
  String.raw`"(?:[^"\\]|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\['"\`\\btrnf])*"`,
  String.raw`[\`\}](?:[^\`\\$]|\\[\s\S]|[$](?!\{))*(?:\`|[$]\{)`,
  // Numbers
  String.raw`(?:[1-9.]|0[.])[0-9.+\-]*[FfIiLlUu]*`,  // TODO: overmatches
  String.raw`0[Xx][0-9A-Fa-f]+[IiLlUu]*`,
  String.raw`0[0-7]*[IiLlUu]*`,
  // Identifiers
  String.raw`${ WORD_START }${ WORD_CONTINUE }*`,
  // Punctuation
  String.raw`[^\w\s/]+`,
  // Regex or div
  // TODO: does not check well-formedness of regexs.  E.g. /(/, /.{1/
  String.raw`(?:/(?![*/])`  // RegExp start and precondition
    + String.raw`(?:[^/\\\[]|\\[^\r\n]|\[(?:[^\\\]]|\\.)*\])+` // RegExp content
    + String.raw`/[gim]*`   // RegExp Flags
    + String.raw`|/=?)`,    // Division operator
  // Comments and whitespace
  (
    '(?:' + [
      String.raw`[\t\n\r ]+`,
      String.raw`//[^\n\r]*`,
      String.raw`/[*](?:[^*]|[*](?!/))*[*]/`,
    ].join('|') + ')+'
  ),
].join('|') + ')$');

/**
 * The least index, i, such that a.codePointAt(i) !== b.codePointAt(i)
 * or the length of the shorter of (a, b) if there is no such i.
 */
function commonPrefixLength(a, b) {
  let minLength = Math.min(a.length, b.length);
  for (let i = 0; i < minLength; ++i) {
    if (a.codePointAt(i) !== b.codePointAt(i)) { return i; }
  }
  return minLength;
}

function formatCodepointAt(s, i) {
  return i < s.length ? 'U+' + s.codePointAt(i).toString(16) : '<nil>';
}
</script>

<h2 id="combinators">Deriving ASTs via Combinators</h2>
<p>
  Many tools properly operate on parse trees, but some, chiefly
  compilers and interpreters, do better with representations that lack
  extraneous details, and are more directly related to language
  specification abstractions or elements of the output.
  &ldquo;Compilers: Principles, Techniques, and Tools&rdquo; by
  Aho, Sethi, Ullman contrasts parse trees with a more abstract tree
  representation:
</p>

<blockquote>
  Abstract syntax trees, or simply syntax trees, differ from parse
  trees because superficial distinctions of form, unimportant for
  translation, do not appear in syntax trees.
</blockquote>

<p>
  Parser combinators are a fine way to turn a source text into a
  parse tree, but they can also be used to derive an abstract syntax
  tree (AST) from a parse tree.
</p>

<p>
  These tests show ASTs.  Each inner AST node has a green border, and
  the node type in small, green print overlapping the top-left of its
  border.  Leaf nodes are black text, have no type, and always
  correspond to tokens in the input.
</p>

<script>
  ta(
    'x = a + b * c;',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "expr",
            "children": [
              {
                "type": "infix",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "id",
                        "children": [
                          "x"
                        ]
                      }
                    ]
                  },
                  "=",
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "infix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "a"
                                ]
                              }
                            ]
                          },
                          "+",
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "infix",
                                "children": [
                                  {
                                    "type": "expr",
                                    "children": [
                                      {
                                        "type": "id",
                                        "children": [
                                          "b"
                                        ]
                                      }
                                    ]
                                  },
                                  "*",
                                  {
                                    "type": "expr",
                                    "children": [
                                      {
                                        "type": "id",
                                        "children": [
                                          "c"
                                        ]
                                      }
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
  ta(
    '{ foo(1); bar(); baz(x,++y); }',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "block",
            "children": [
              {
                "type": "expr",
                "children": [
                  {
                    "type": "call",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "id",
                            "children": [
                              "foo"
                            ]
                          }
                        ]
                      },
                      {
                        "type": "actuals",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "literal",
                                "children": [
                                  "1"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "expr",
                "children": [
                  {
                    "type": "call",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "id",
                            "children": [
                              "bar"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "expr",
                "children": [
                  {
                    "type": "call",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "id",
                            "children": [
                              "baz"
                            ]
                          }
                        ]
                      },
                      {
                        "type": "actuals",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "prefix",
                                "children": [
                                  "++",
                                  {
                                    "type": "expr",
                                    "children": [
                                      {
                                        "type": "id",
                                        "children": [
                                          "y"
                                        ]
                                      }
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
  ta(
    '{ let x = 0; while(bar()) { ++x; } return x; }',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "block",
            "children": [
              {
                "type": "decl",
                "children": [
                  {
                    "type": "let",
                    "children": [
                      {
                        "type": "id",
                        "children": [
                          "x"
                        ]
                      },
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "literal",
                            "children": [
                              "0"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "while",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "call",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "bar"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "type": "block",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "prefix",
                            "children": [
                              "++",
                              {
                                "type": "expr",
                                "children": [
                                  {
                                    "type": "id",
                                    "children": [
                                      "x"
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "return",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "id",
                        "children": [
                          "x"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
  ta(
    'if (a) { x++; } else if (b) { y++; } else { z++; }',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "if",
            "children": [
              {
                "type": "expr",
                "children": [
                  {
                    "type": "id",
                    "children": [
                      "a"
                    ]
                  }
                ]
              },
              {
                "type": "block",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "postfix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          "++"
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "else",
                "children": [
                  {
                    "type": "if",
                    "children": [
                      {
                        "type": "expr",
                        "children": [
                          {
                            "type": "id",
                            "children": [
                              "b"
                            ]
                          }
                        ]
                      },
                      {
                        "type": "block",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "postfix",
                                "children": [
                                  {
                                    "type": "expr",
                                    "children": [
                                      {
                                        "type": "id",
                                        "children": [
                                          "y"
                                        ]
                                      }
                                    ]
                                  },
                                  "++"
                                ]
                              }
                            ]
                          }
                        ]
                      },
                      {
                        "type": "else",
                        "children": [
                          {
                            "type": "block",
                            "children": [
                              {
                                "type": "expr",
                                "children": [
                                  {
                                    "type": "postfix",
                                    "children": [
                                      {
                                        "type": "expr",
                                        "children": [
                                          {
                                            "type": "id",
                                            "children": [
                                              "z"
                                            ]
                                          }
                                        ]
                                      },
                                      "++"
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
  ta(
    'for (x = 0; x < 0; x++) { f(x); }',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "for",
            "children": [
              {
                "type": "forinit",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "infix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          "=",
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "literal",
                                "children": [
                                  "0"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "forcond",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "infix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          "<",
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "literal",
                                "children": [
                                  "0"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "forincr",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "postfix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "x"
                                ]
                              }
                            ]
                          },
                          "++"
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "type": "block",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "call",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "id",
                                "children": [
                                  "f"
                                ]
                              }
                            ]
                          },
                          {
                            "type": "actuals",
                            "children": [
                              {
                                "type": "expr",
                                "children": [
                                  {
                                    "type": "id",
                                    "children": [
                                      "x"
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
</script>

<p>And this doesn&apos;t prevent containing errors:</p>

<script>
  ta(
    'do { problem /* MISSING SEMICOLON */ } while (cond);',
    [
      {
        type: 'program',
        children: [
          {
            type: 'do',
            children: [
              {
                type: 'block',
                children: [{ type: 'ERROR', discards: ['problem'] }]
              },
              {
                type: 'expr',
                children: [{ type: 'id', children: ['cond'] }]
              }
            ]
          }
        ]
      }
    ],
  );

  ta(
    'x += (y * ) + 3;',
    [
      {
        "type": "program",
        "children": [
          {
            "type": "expr",
            "children": [
              {
                "type": "infix",
                "children": [
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "id",
                        "children": [
                          "x"
                        ]
                      }
                    ]
                  },
                  "+=",
                  {
                    "type": "expr",
                    "children": [
                      {
                        "type": "infix",
                        "children": [
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "ERROR",
                                "discards": [
                                  "IN",
                                  "IN",
                                  "y",
                                  "DE",
                                  "*",
                                  "DE"
                                ]
                              }
                            ]
                          },
                          "+",
                          {
                            "type": "expr",
                            "children": [
                              {
                                "type": "literal",
                                "children": [
                                  "3"
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );

  ta(
    'function f(x) { return x + ; }',
    [
      {
        type: 'program',
        children: [
          {
            type: 'decl',
            children: [
              {
                type: 'function',
                children: [
                  'f',
                  {
                    type: 'formals',
                    children: [
                      {
                        type: 'formal',
                        children: [{ type: 'id', children: ['x'] }]
                      }
                    ]
                  },
                  {
                    type: 'block',
                    children: [
                      {
                        type: 'ERROR',
                        discards: [
                          'return', 'IN', 'IN', 'x',
                          'DE', '+', 'DE'
                        ]
                      },
                      {
                        type: 'nop',
                        children: []
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );

  ta(
    'f(x, y +, z);',
    [
      {
        type: 'program',
        children: [
          {
            type: 'expr',
            children: [
              {
                type: 'call',
                children: [
                  {
                    type: 'expr',
                    children: [{ type: 'id', children: ['f'] }]
                  },
                  {
                    type: 'actuals',
                    children: [
                      {
                        type: 'expr',
                        children: [{ type: 'id', children: ['x'] }]
                      },
                      {
                        type: 'ERROR',
                        discards: [
                          'IN',
                          'IN',
                          'y',
                          'DE',
                          '+',
                          'DE'
                        ]
                      },
                      {
                        type: 'expr',
                        children: [{ type: 'id', children: ['z'] }]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );

  ta(
    '{ do; f(); }',
    [
      {
        type: 'program',
        children: [
          {
            type: 'block',
            children: [
              {
                type: 'ERROR',
                discards: ['do'],
              },
              {
                type: 'nop',
                children: []
              },
              {
                type: 'expr',
                children: [
                  {
                    type: 'call',
                    children: [
                      {
                        type: 'expr',
                        children: [{ type: 'id', children: ['f'] }]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
</script>

<p>Combinators operate on a sequence of tokens, so, first, we need to
transform our parse tree into a sequence.</p>

<table id="flattening-example-table">
  <caption>Flattening a parse tree</caption>
  <tr><th>Input<td style="font-family: Lucida">&ldquo;<td><td class="kwd">let<td><td>x<td><td class="pun">=<td><td class="lit">1<td><td class="pun">;<td style="font-family: Lucida">&rdquo;</tr>
  <tr><th>Tokens<td><td><td class="str">"let"<td><td class="str">"x"<td><td class="str">"="<td><td class="str">"1"<td><td class="str">";"<td></tr>
  <tr><th>Parse Tree<td class="pun">[<td class="pun">[<td class="str">"let"<td class="pun">,<td class="str">"x"<td class="pun">],<td class="str">"="<td class="pun">, [<td class="str">"1"<td class="pun">],<td class="str">";"<td class="pun">]</tr>
  <tr><th>Flat Tree<td>&#x21e8;<td>&#x21e8;<td class="str">"let"<td><td class="str">"x"<td>&#x21e6;<td class="str">"="<td>&#x21e8;<td class="str">"1"<td>&#x21e6;<td class="str">";"<td>&#x21e6;</tr>
</table>

<p>As you can see, a flattened parse tree:</p>
<ul>
  <li>is a series of tokens and pseudo-tokens.</li>
  <li>uses a single kind of bracket (&#x21e8;&hellip;&#x21e6; above).</li>
  <li>is always balanced even for malformed parse trees.</li>
  <li>is consumable by parser combinators.</li>
</ul>

<p id="concept-syntax-tree-flatten">
  The flatten function takes a parse tree and produces a sequence
  with indent and dedent pseudo-tokens around the content of each inner
  node.
</p>

<script class="visible">
class PseudoTokIndent {   // Pseudo-token that marks start of inner node
  constructor(op) {
    this.op = op;
  }
  toString() { return '\u21e8' }
  toJSON() { return 'IN'; }
};
class PseudoTokDedent {   // Pseudo-token that marks end of inner node
  constructor(op) {
    this.op = op;
  }
  toString() { return '\u21e6' }
  toJSON() { return 'DE'; }
};

/** Turns a parse tree into a series of s-expr like tokens. */
function flattenParseTreeToPseudoTokens(parseTree) {
  const out = [];
  if (parseTree.op === rootOperator) {
    for (const toplevel of parseTree) {
      walk(toplevel);
    }
  } else {
    walk(parseTree);
  }
  return out;

  function walk(parseTree) {
    if (isLeafNode(parseTree)) {
      out.push(parseTree);
    } else if (Array.isArray(parseTree)) {
      const op = parseTree.op;
      out.push(new PseudoTokIndent(op));
      for (const child of parseTree) {
        walk(child);
      }
      out.push(new PseudoTokDedent(op));
    } else {
      throw new Error(parseTree);
    }
  }
}
</script>

<p>
  Because the flattened tree contains explicit &#x21e8; and &#x21e6;
  it can be consumed by simple combinators that make no special
  provisions for either Left- or Right- recursion.
</p>

<p id="concept-ast-lift">
  There&apos;s nothing novel about the combinator definitions, so if you
  already know how combinator libraries tend to work, you can gloss
  over them without missing much.  The main thing to note is that they
  don&apos;t use side-effects to build a parse tree.  Combinators read an
  input buffer containing a flattened parse tree and build a flattened
  AST by appending to an output buffer which is then
  &ldquo;lifted&rdquo; into a proper tree in a reverse of the flatten
  function used above.
</p>

<details>
  <summary>Definitions of combinators</summary>
<script class="visible">
const combinators = (() => {
  // A combinator is a function(context, position)
  // where context has the form {
  //   input,    // a list of "tokens" to process
  //   output,   // which combinators may append to if they succeed
  //   grammar,  // used to lookup productions
  // },
  // and position is an index into context.input.
  // A combinator returns null to indicate match failure,
  // or otherwise the position after application which must
  // be >= the input position.

  /** A grammar maps names to positions. */
  class Grammar {
    constructor(declarations = {}) {
      this.productions = new Map();
      for (const name of Object.getOwnPropertyNames(declarations)) {
        this.declare(name, declarations[name]);
      }
    }
    declare(name, body) {
      if (this.productions.has(name)) {
        throw new Error(`duplicate ${ name }`);
      }
      this.productions.set(name, toCombinator(body));
    }
    /**
     * Applies the named production to the input.
     * Returns null or {output, position} where
     * position is after parse.
     * To fail when not all input is matched, use
     * the EOF combinator.
     */
    apply(name, input) {
      const context = {
        grammar: this,
        input: [...input],
        output: [],
      };

      const after = Ref(name)(context, 0);
      return typeof after === 'number'
        ? { ast: lift(context.output), position: after }
        : null;
    }
    getProduction(name) {
      return this.productions.get(name);
    }
    productionNames() {
      return this.productions.keys();
    }
  }

  // Here are some outputs that allow building an AST.
  class EnterEvent {  // Starts an AST node
    constructor(name) { this.name = name; }
    toString() { return `(Enter ${ this.name })`; }
    toJSON() { return this.toString(); }
  }
  class ExitEvent {  // Ends an AST node
    constructor(name) { this.name = name; }
    toString() { return `(Exit ${ this.name })`; }
    toJSON() { return this.toString(); }
  }
  class ErrorEvent {  // Indicates that problem tokens were discarded
    constructor(discards) { this.discards = discards; }
    toString() { return 'ERROR'; }
    toJSON() {
      return { type: 'ERROR', discards: this.discards };
    }
  }

  /** "Lifting" is turning a series of AST pseudo-tokens into an AST. */
  function lift(astPseudoTokens) {
    const n = astPseudoTokens.length;
    function liftSome(pos, items) {
      for (let i = pos; i < n; ++i) {
        const pt = astPseudoTokens[i];
        if (pt instanceof ExitEvent) {
          return i;
        } else if (pt instanceof EnterEvent) {
          const t = {
            type: pt.name,
            children: [],
          };
          i = liftSome(i + 1, t.children);
          if (i < n && astPseudoTokens[i] instanceof ExitEvent) {
            // ++i above will consume
            items.push(t);
          } else {
            throw new Error(`unbalanced at ${ i }`);
          }
        } else {
          items.push(pt);
        }
      }
      return n;
    }
    const forest = [];
    liftSome(0, forest);
    return forest;
  }

  const EPSILON = Cat();

  // Implicit coercion for combinators
  function toCombinator(x) {
    if (typeof x === 'function') {
      return x;
    } else if (typeof x === 'string') {
      const match = /^<([a-z]+)(_opt)?([.])?>$/.exec(x);
      if (match) {
        const ref = Ref(match[1], !match[3]);
        return match[2] ? Or(ref, EPSILON) : ref;
      }
      return Match(x, false);
    } else if (Array.isArray(x)) {
      return Cat(...x);
    } else if (typeof x.test === 'function') {
      return Match(x, true);
    } else {
      console.error('toCombinator(%o)', x);
      throw new Error(x);
    }
  }

  /** A reference to a production. */
  function Ref(name, nests = true) {
    return (context, position) => {
      const outputLengthAtStart = context.output.length;
      if (nests) { context.output.push(new EnterEvent(name)); }
      // Optimistically assume no LR.  We don't need LR
      // since the operator precedence parser parenthesizes for us.
      const rhs = context.grammar.getProduction(name);
      if (!rhs) {
        throw new Error(`No definition for production ${ name }`);
      }
      const afterSeed = rhs(context, position);
      if (typeof afterSeed !== 'number') {
        context.output.length = outputLengthAtStart;
        return null;
      }
      if (nests) { context.output.push(new ExitEvent(name)); }
      return afterSeed;
    };
  }

  /** Concatenation. */
  function Cat(...parts) {
    parts = parts.map(toCombinator);
    return (context, position) => {
      const outputLengthAtStart = context.output.length;
      let after = position;
      for (const part of parts) {
        after = part(context, after);
        if (typeof after !== 'number') {
          context.output.length = outputLengthAtStart;
          return null;
        }
      }
      return after;
    };
  }
  /** Alternation. */
  function Or(...options) {
    options = options.map(toCombinator);
    return (context, position) => {
      for (const option of options) {
        let after = option(context, position);
        if (typeof after === 'number') {
          return after;
        }
      }
      return null;
    };
  }
  /**
   * Matches an input token.
   * If emit is truthy, matched content is copied to the output.
   */
  function Match(pattern, emit) {
    return ({ input, output }, position) => {
      if (input.length > position) {
        let target = input[position];
        if (isLeafNode(target)) {
          target = target.tok;
        }
        const matched = pattern instanceof RegExp
              ? typeof target === 'string' && pattern.test(target)
              : typeof pattern === 'function'
              ? pattern(target) === true
              : pattern === target;
        if (matched) {
          if (emit) { output.push(input[position]); }
          return position + 1;
        }
      }
      return null;
    };
  }

  return {
    PseudoTokIndent,
    PseudoTokDedent,
    Grammar,
    // Combinator constructors.
    Ref,
    /** Kleene plus style repetition. */
    Rep(body) {
      body = toCombinator(body);
      return (context, position) => {
        let before = position;
        let after = body(context, before);
        if (typeof after !== 'number') {
          return null;
        }
        while (typeof after === 'number' && after > before) {
          before = after;
          after = body(context, before);
        }
        return before;
      };
    },
    Cat,
    Or,
    Opt(...bodies) { return Or(...bodies, EPSILON); },
    Want(x) { return Match(x, false); },
    Echo(x) { return Match(x, true); },
    NegLA(body) {
      body = toCombinator(body);
      return (context, position) => {
        const outputLengthAtStart = context.output.length;
        if ('number' === typeof body(context, position)) {
          context.output.length = outputLengthAtStart;
          return null;
        } else {
          return position;
        }
      };
    },
    Garbage({ stopBefore = closeBrackets, stopAfter = [], requireSome } = {}) {
      stopBefore = new Set(stopBefore);
      stopAfter = new Set(stopAfter);

      return ({ input, output }, position) => {
        let nIndent = 0;
        let after;
        for (after = position; after < input.length; ++after) {
          const inp = input[after];
          if (inp instanceof PseudoTokIndent) {
            ++nIndent;
          } else if (inp instanceof PseudoTokDedent) {
            if (nIndent === 0) { break; }
            --nIndent;
          } else if (isLeafNode(inp) && nIndent === 0) {
            if (stopAfter && stopAfter.has(inp.tok)) {
              ++after;
              break;
            }
            if (stopBefore.has(inp.tok)) {
              break;
            }
          }
        }
        if (after > position) {
          output.push(new ErrorEvent(input.slice(position, after)));
          return after;
        }
        return requireSome ? null : after;
      };
    },
    Debug(description, body) {
      body = toCombinator(body);
      return (context, position) => {
        const { input } = context;
        console.group(`${ description } @ ${ position } : ${
            position < input.length ? input[position].tok : 'none'
        }`);
        let result;
        try {
          result = body(context, position);
          if (result !== null) {
            console.log(`Application succeeded -> ${ result }`);
          } else {
            console.log('Application failed');
          }
        } finally {
          console.groupEnd();
        }
        return result;
      };
    },
    Operator(tok) {
      return (context, position) => {
        const { input } = context;
        if (position < input.length) {
          const next = input[position];
          if (next instanceof PseudoTokIndent && next.op.tok === tok) {
            return position;
          }
        }
        return null;
      };
    },
    // Singletons
    EPSILON,
    EOF({ input }, position) {
      return (input.length === position) ? position : null;
    },
    // The indent and dedent tokens mark the start and end of parse tree nodes
    // in the pseudo-token list formed from a flattened parse tree that is fed
    // to combinators/grammars.
    IN: Match((x) => x instanceof PseudoTokIndent, false),
    DE: Match((x) => x instanceof PseudoTokDedent, false),
    // Output event classes
    EnterEvent,
    ExitEvent,
  };
})();
</script>
</details>

<p>
  Here is a grammar for a toy language that looks like TypeScript.
  This grammar has gaps (no <code>switch</code>); it is too long already.
</p>

<script class="visible" id="toy-grammar">
function makeToyLanguageGrammar({
  // Combinators and constructors for combinators defined later.
  Grammar, /*Con*/Cat/*enate*/, NegLA, Opt/*ional*/, Or, Ref/*erence*/,
  Rep/*etition*/, Want /*consumes*/, Garbage /*eats bad tokens*/,
  Operator, EOF, IN/*DENT*/, DE/*DENT*/, Debug,
}) {
  // Matches identifiers.
  const idPattern = new RegExp(
    String.raw`^(?!(?:${
      // Reserved keywords
      'break|continue|do|else|for|function|if|let|new|return|throw|while'
    })$)@?${ WORD_START }${ WORD_CONTINUE }*$`);
  const litPattern = /^(?:[.]?\d|[\'\"]|\/.*\/[gim]*$)/;

  return {
    // This object constructor relates property names to combinators.

    // Nonterminals are in angle brackets, so
    //   '<foo>'
    // is a reference to the combinator to the right of
    //   foo:
    // and if that combinator succeeds, the output gets an AST node
    // with {type:'foo'}.

    // '<foo.>' is a "silent" reference.  The output will not have an AST
    // node with {type:'foo'}.  Instead, the children that would be in
    // that node will be inlined in its would-be parent.

    // '<foo_opt>' is an optional reference; it is shorthand for
    // Opt('<foo>').


    // Programs match when it can eat <toplevels> and doing so
    // processes the entire input (reaches end-of-file).
    program: ['<toplevels.>', EOF],
    toplevels: Opt(Rep(
      Or(
        [Operator(';'), IN, Rep('<toplevel.>'), DE],
        '<toplevel.>')
    )),
    toplevel: Or(
      '<decl>',
      '<stmt.>',
      // We try to recover from errors if the input doesn't contain
      // a declaration or a statement.
      [IN, Garbage({ stopAfter: [';'], stopBefore: ['}'] }), DE],
      Garbage(),
    ),

    stmt: Or(
      '<if>', '<for>', '<while>', '<do>',
      '<return>', '<break>', '<continue>', '<throw>',
      '<nop>',
      // TODO: switch, try, yield, labeled statements
      [ Operator('{'), IN, '<block>', DE ],
      // This means consume an indent pseudo-token, match expression,
      // consume a literal ';' token, consume a dedent pseudo-token.
      ['<commaexpr.>', ';'],
    ),
    decl: Or([ '<let>', ';' ], '<function>'),

    if: Or(
      [IN, IN, IN, 'if', DE, '(', '<expr>', ')', DE, '<block>', DE],
      [IN, IN, IN, IN, 'if', DE, '(', '<expr>', ')', DE, '<block>', DE,
       '<else>', DE],
    ),

    else: Or(
      ['else', IN, '<block>', DE],
      ['else', '<if>'],
    ),

    for: Or(
      [
        IN, IN, IN, 'for', DE, '(',
        IN, '<forinit_opt>', ';', '<forcond_opt>', ';', '<forincr_opt>', DE,
        ')', DE, '<block>', DE
      ],
      // TODO: for...in, for...of
    ),

    forinit: Or('<let>', '<commaexpr.>'),
    forcond: '<expr>',
    forincr: '<commaexpr.>',

    while: [
      IN, IN, IN, 'while', DE, '(', '<expr>', ')', DE, '<block>', DE,
    ],

    do: [
      IN, IN,
      'do', IN, '<block>', DE, DE, 'while', IN, '(', '<expr>', ')',
      DE, DE, ';'
    ],

    return: [IN, 'return', '<expr_opt>', DE, ';'],

    throw: [IN, 'throw', '<expr_opt>', DE, ';'],

    nop: [';'],

    label: idPattern,

    break: [IN, 'break', '<label_opt>', DE, ';'],
    continue: [IN, 'continue', '<label_opt>', DE, ';'],

    block: ['{', '<toplevels.>', '}'],

    let: Or(
      [Operator(','), IN, '<letbody.>', Opt(Rep([',', '<letrest.>'])), DE],
      '<letbody.>'
    ),

    letbody: Or(
      [IN, 'let', '<id>', DE],
      [IN, IN, 'let', '<id>', DE, '=', '<commael.>', DE],
      [IN, IN, 'let', '<id>', DE, ':', '<type>', DE],
      [IN, IN, IN, 'let', '<id>', DE, ':', '<type>', DE, '=', '<commael.>', DE],
    ),

    letrest: Or(
      [IN, '<id>', DE],
      [IN, IN, '<id>', DE, '=', '<expr>', DE],
      [IN, IN, '<id>', DE, ':', '<type>', DE],
      [IN, IN, IN, '<id>', DE, ':', '<type>', DE, '=', '<expr>', DE],
    ),

    type: Or(
      '<nominaltype>',
      '<generictype>',
      '<uniontype>',
      // TODO: record type
      [IN, '(', '<type.>', ')', DE],
    ),
    nominaltype: [IN, '<id>', DE],
    generictype: [IN, '<type.>', '<', '<typeparams>', '>', DE],
    uniontype: [IN, Or('<uniontype.>', '<type.>'), '|', '<type.>', DE],
    typeparams: Or(
      [Operator(','), IN, '<type.>', Rep([',', '<type.>']), DE],
      '<type.>'
    ),
    rettype: '<type.>',

    function: [
      IN, IN, IN, 'function', idPattern, DE, '(', '<formals_opt>', ')', DE,
      Or(
        [ '<block>', DE],
        [ ':', IN, '<rettype>', '<block>', DE, DE],
      )
    ],
    formals: Or(
      [Operator(','), IN, '<formal>', Rep([',', '<formal>']), DE],
      '<formal>',
    ),

    formal: '<letrest.>',

    commaexpr: Or(
      '<commaop>',
      '<expr>',
    ),
    commaop: [Operator(','), IN, '<commael.>', Rep([',', '<commael.>']), DE],
    commael: Or(
      '<expr>',
      Garbage({ stopBefore: [',', ...closeBrackets] }),
    ),

    expr: Or(
      '<literal>',
      '<id>',
      '<template>',
      // Parentheses for grouping
      [
        IN, '(',
        Or('<commaop>', '<expr.>', Garbage({ stopBefore: [')'] })),
        ')', DE
      ],
      '<array>',
      '<prefix>',
      '<infix>',
      '<call>',
      '<new>',
      '<obj>',
      '<postfix>',
      '<member>',
      // TODO: instanceof
      [IN, '(',
       Garbage({ stopBefore: [',', ';', ...closeBrackets], stopAfter: [')'] }),
       DE],
    ),

    literal: Or([IN, litPattern, DE], litPattern),
    id: Or([IN, idPattern, DE], idPattern),
    array: [
      IN, '[',
      Or('<arrayels.>', '<expr>', Garbage({ stopBefore: [']']})),
      ']', DE],

    arrayels: [IN, '<arrayel.>', Opt(Rep([',', '<arrayel.>'])), Opt(','), DE],
    arrayel: Or(
      '<expr>',
      '<spread>',
      // TODO: elision as in [a,,b] and [a,,,b]
      Garbage({ stopBefore: [',', ...closeBrackets]}),
    ),
    spread: [IN, '...', '<expr>', DE],

    infix: Or(
      [IN, '<expr>', /^[+\-*/=%^&|!<>.~]+$/, '<expr>', DE],
      [IN, '<expr>', /^[?]$/, '<expr>', /^:$/, '<expr>', DE],
    ),
    call: [IN, '<expr>', '(', '<actuals_opt>', ')', DE],
    // Matches a JS style {propname:value} expr.
    obj: [IN, '{', Opt('<props>'), '}', DE],
    props: Or(
      [IN, '<prop.>', Rep([',', '<prop.>']), Opt(','), DE],
    ),
    prop: [IN, IN, '<id>', DE, ':', '<expr>', DE],
    prefix: [IN, /^[!\-+]/, '<expr>', DE],
    postfix: [IN, '<expr>', /^(?:--|\+\+)$/, DE],
    new: [IN, IN, 'new', '<type.>', DE, '(', '<actuals_opt>', ')', DE],
    member: [IN, '<expr>', '[', '<commaexpr.>', ']', DE],

    template: [
      IN,
      Opt([NegLA([ '(', IN, /^`/]), '<ttag>']),
      '(', IN,
      Or(
        [/^`(?:[^`\\]|\\[\s\S])*`$/],
        [/^`(?:[^`\\]|\\[\s\S])*[$]\{$/, DE,
         '<hole>',
         Opt(Rep([IN, /^\}(?:[^`\\]|\\[\s\S])*[$]\{$/, DE, '<hole>'])),
         IN, /^\}(?:[^`\\]|\\[\s\S])*`$/],
      ),
      DE, ')', DE
    ],
    hole: [
      IN, '(', Or('<commaexpr.>', Garbage({ stopBefore: [')'] })), ')', DE
    ],
    ttag: [
      '<expr>',
    ],

    actuals: Or(
      '<commaop.>',
      '<expr>',
      Garbage({ stopBefore: [')'], requireSome: true }),
    ),
  };
}
</script>

<script class="visible hoisted" id="grammar-support-for-quasis">
makeToyLanguageGrammar = ((oldMakeGrammar) => ((combinators) => {
  const { Opt/*ional*/, Rep/*etition*/, Or, IN, DE } = combinators;

  const productions = {
    ...oldMakeGrammar(combinators),

    // Extra productions for quasi-quoting
    qtree:  [IN, '\\{', Opt(Rep(Or('<qhole>', '<qinner>'))), '}', DE],
    qast:   [IN, '\\(', Or('<expr>', '<toplevel>'), ')', DE],
    qnodes: Opt(Rep(Or('<qhole>', '<qinner>', '<qleaf>'))),
    qhole:  [IN, '${', '<commaexpr.>', '}', DE],
    qinner: [IN, '<qnodes.>', DE],
    qleaf:  /^/,  // Matches any token.
  };
  // A quasi-quotation is an expression.
  productions.expr = Or(
    '<qtree>',
    '<qast>',
    productions.expr
  );
  // Since <expr> and <toplevel> can appear inside \( ... ),
  // we need to allow qholes in important places.
  for (const name of ['expr', 'label', 'stmt', 'type']) {
    if (!productions[name]) { throw new Error(name); }
    productions[name] = Or('<qhole>', productions[name]);
  }
  return productions;
}))(makeToyLanguageGrammar);
</script>

<p>Unless otherwise stated, examples hereafter use this transform from
parse trees to ASTs:</p>

<script class="visible">
const toyLanguageGrammar = new combinators.Grammar(
  makeToyLanguageGrammar(combinators));
</script>

<p>The rest of the end-to-end tests are a bit duplicative.</p>

<details>
  <summary>Let statement tests</summary>
  <script>
    ta(
      'let x;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [{ type: 'id', children: ['x'] }]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x = 1;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    {
                      type: 'id',
                      children: ['x']
                    },
                    {
                      type: 'expr',
                      children: [{ type: 'literal', children: ['1'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x : number;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    {
                      type: 'id',
                      children: ['x']
                    },
                    {
                      type: 'type',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['number'] }]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x : number = 1;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    {
                      type: 'id',
                      children: ['x']
                    },
                    {
                      type: 'type',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['number'] }]
                        }
                      ]
                    },
                    {
                      type: 'expr',
                      children: [{ type: 'literal', children: ['1'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x : number, y = 1;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    { type: 'id', children: ['x'] },
                    {
                      type: 'type',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['number'] }]
                        }
                      ]
                    },
                    { type: 'id', children: ['y'] },
                    {
                      type: 'expr',
                      children: [{ type: 'literal', children: ['1'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x, y, z;',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    { type: 'id', children: ['x'] },
                    { type: 'id', children: ['y'] },
                    { type: 'id', children: ['z'] }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'let x : T<A, B> | false = a < b && new T();',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'let',
                  children: [
                    { type: 'id', children: ['x'] },
                    {
                      type: 'type',
                      children: [
                        {
                          type: 'uniontype',
                          children: [
                            {
                              type: 'generictype',
                              children: [
                                {
                                  type: 'nominaltype',
                                  children: [{ type: 'id', children: ['T'] }]
                                },
                                {
                                  type: 'typeparams',
                                  children: [
                                    {
                                      type: 'nominaltype',
                                      children: [{ type: 'id', children: ['A'] }]
                                    },
                                    {
                                      type: 'nominaltype',
                                      children: [{ type: 'id', children: ['B'] }]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              type: 'nominaltype',
                              children: [{ type: 'id', children: ['false'] }]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'infix',
                          children: [
                            {
                              type: 'expr',
                              children: [
                                {
                                  type: 'infix',
                                  children: [
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['a'] }]
                                    },
                                    '<',
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['b'] }]
                                    }
                                  ]
                                }
                              ]
                            },
                            '&&',
                            {
                              type: 'expr',
                              children: [
                                {
                                  type: 'new',
                                  children: [
                                    {
                                      type: 'nominaltype',
                                      children: [{ type: 'id', children: ['T'] }]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'x = new T<u>(a < b, c > d);',
      [
        {
          type: 'program',
          children: [
            {
              type: 'expr',
              children: [
                {
                  type: 'infix',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['x'] }]
                    },
                    '=',
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'new',
                          children: [
                            {
                              type: 'generictype',
                              children: [
                                {
                                  type: 'nominaltype',
                                  children: [{ type: 'id', children: ['T'] }]
                                },
                                {
                                  type: 'typeparams',
                                  children: [
                                    {
                                      type: 'nominaltype',
                                      children: [{ type: 'id', children: ['u'] }]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              type: 'actuals',
                              children: [
                                {
                                  type: 'expr',
                                  children: [
                                    {
                                      type: 'infix',
                                      children: [
                                        {
                                          type: 'expr',
                                          children: [{ type: 'id', children: ['a'] }]
                                        },
                                        '<',
                                        {
                                          type: 'expr',
                                          children: [{ type: 'id', children: ['b'] }]
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  type: 'expr',
                                  children: [
                                    {
                                      type: 'infix',
                                      children: [
                                        {
                                          type: 'expr',
                                          children: [{ type: 'id', children: ['c'] }]
                                        },
                                        '>',
                                        {
                                          type: 'expr',
                                          children: [{ type: 'id', children: ['d'] }]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
  </script>
</details>

<details>
  <summary>For loop tests</summary>
  <script>
    ta(
      'for (let x : number = 1, n = 10; i < n; ++i) { body; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'forinit',
                  children: [
                    {
                      type: 'let',
                      children: [
                        { type: 'id', children: ['x'] },
                        {
                          type: 'type',
                          children: [
                            {
                              type: 'nominaltype',
                              children: [{ type: 'id', children: ['number'] }]
                            }
                          ]
                        },
                        {
                          type: 'expr',
                          children: [{ type: 'literal', children: ['1'] }]
                        },
                        { type: 'id', children: ['n'] },
                        {
                          type: 'expr',
                          children: [{ type: 'literal', children: ['10'] }]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'forcond',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'infix',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['i'] }]
                            },
                            '<',
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['n'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'forincr',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'prefix',
                          children: [
                            '++',
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['i'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'block',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['body'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'for (x = 1, y = 10; x < y; ++x, --y) { console.log(x, y); }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'forinit',
                  children: [
                    {
                      type: 'commaop',
                      children: [
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'infix',
                              children: [
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['x'] }]
                                },
                                '=',
                                {
                                  type: 'expr',
                                  children: [{ type: 'literal', children: ['1'] }]
                                }
                                  ]
                            }
                          ]
                        },
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'infix',
                              children: [
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['y'] }]
                                },
                                '=',
                                {
                                  type: 'expr',
                                  children: [{ type: 'literal', children: ['10'] }]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'forcond',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'infix',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['x'] }]
                            },
                            '<',
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['y'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'forincr',
                  children: [
                    {
                      type: 'commaop',
                      children: [
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'prefix',
                              children: [
                                '++',
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['x'] }]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'prefix',
                              children: [
                                '--',
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['y'] }]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'block',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'call',
                          children: [
                            {
                              type: 'expr',
                              children: [
                                {
                                  type: 'infix',
                                  children: [
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['console'] }]
                                    },
                                    '.',
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['log'] }]
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              type: 'actuals',
                              children: [
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['x'] }]
                                },
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['y'] }]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'for (; f();) { g(); }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'forcond',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'call',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['f'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'block',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'call',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['g'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'for (;;) { if (f()) { break; } }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'block',
                  children: [
                    {
                      type: 'if',
                      children: [
                        {
                          type: 'expr',
                          children: [
                            {
                              type: 'call',
                              children: [
                                {
                                  type: 'expr',
                                  children: [{ type: 'id', children: ['f'] }]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          type: 'block',
                          children: [{ type: 'break', children: [] }]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'for (;; f()) { break label; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'for',
              children: [
                {
                  type: 'forincr',
                  children: [
                    {
                      type: 'expr',
                      children: [
                        {
                          type: 'call',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['f'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'block',
                  children: [
                    {
                      type: 'break',
                      children: [{ type: 'label', children: ['label'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]    );
  </script>
</details>

<details>
  <summary>Function declaration tests</summary>
  <script>
    ta(
      'function f() { return; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'function',
                  children: [
                    'f',
                    {
                      type: 'block',
                      children: [{ type: 'return', children: [] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'function f(x) { return x; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'function',
                  children: [
                    'f',
                    {
                      type: 'formals',
                      children: [
                        {
                          type: 'formal',
                          children: [{ type: 'id', children: ['x'] }]
                        }
                      ]
                    },
                    {
                      type: 'block',
                      children: [
                        {
                          type: 'return',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['x'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'function f(x: number): number { return (x); }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'function',
                  children: [
                    'f',
                    {
                      type: 'formals',
                      children: [
                        {
                          type: 'formal',
                          children: [
                            { type: 'id', children: ['x'] },
                            {
                              type: 'type',
                              children: [
                                {
                                  type: 'nominaltype',
                                  children: [{ type: 'id', children: ['number'] }]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      type: 'rettype',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['number'] }]
                        }
                      ]
                    },
                    {
                      type: 'block',
                      children: [
                        {
                          type: 'return',
                          children: [
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['x'] }]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'function f(x: number, y = null): number|string { return y ? x : "" + x; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'decl',
              children: [
                {
                  type: 'function',
                  children: [
                    'f',
                    {
                      type: 'formals',
                      children: [
                        {
                          type: 'formal',
                          children: [
                            { type: 'id', children: ['x'] },
                            {
                              type: 'type',
                              children: [
                                {
                                  type: 'nominaltype',
                                  children: [{ type: 'id', children: ['number'] }]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          type: 'formal',
                          children: [
                            { type: 'id', children: ['y'] },
                            {
                              type: 'expr',
                              children: [{ type: 'id', children: ['null'] }]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      type: 'rettype',
                      children: [
                        {
                          type: 'uniontype',
                          children: [
                            {
                              type: 'nominaltype',
                              children: [{ type: 'id', children: ['number'] }]
                            },
                            {
                              type: 'nominaltype',
                              children: [{ type: 'id', children: ['string'] }]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      type: 'block',
                      children: [
                        {
                          type: 'return',
                          children: [
                            {
                              type: 'expr',
                              children: [
                                {
                                  type: 'infix',
                                  children: [
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['y'] }]
                                    },
                                    '?',
                                    {
                                      type: 'expr',
                                      children: [{ type: 'id', children: ['x'] }]
                                    },
                                    ':',
                                    {
                                      type: 'expr',
                                      children: [
                                        {
                                          type: 'infix',
                                          children: [
                                            {
                                              type: 'expr',
                                              children: [{ type: 'literal', children: ['\"\"'] }]
                                            },
                                            '+',
                                            {
                                              type: 'expr',
                                              children: [{ type: 'id', children: ['x'] }]
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
  </script>
</details>

<details>
  <summary>More expression tests</summary>
  <script>
    ta(
      'new T<A, B>(x)',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'new',
              children: [
                {
                  type: 'generictype',
                  children: [
                    {
                      type: 'nominaltype',
                      children: [{ type: 'id', children: ['T'] }]
                    },
                    {
                      type: 'typeparams',
                      children: [
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['A'] }]
                        },
                        {
                          type: 'nominaltype',
                          children: [{ type: 'id', children: ['B'] }]
                        }
                      ]
                    }
                  ]
                },
                {
                  type: 'actuals',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['x'] }]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '[a, ...b, c]',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'array',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['a'] }]
                },
                {
                  type: 'spread',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['b'] }]
                    }
                  ]
                },
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['c'] }]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      'array[i]',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'member',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['array'] }]
                },
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['i'] }]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '/a*|b+|[cd]/g',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'literal',
              children: ['/a*|b+|[cd]/g']
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '`a${ b }c`',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'template',
              children: [
                '`a${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['b'] }]
                    }
                  ]
                },
                '}c`'
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '`....`',
      [
        {
          type: 'expr',
          children: [{ type: 'template', children: ['`....`'] }]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '`a${ b }\${c}${d,d}...${e}`',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'template',
              children: [
                '`a${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['b'] }]
                    }
                  ]
                },
                '}${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['c'] }]
                    }
                  ]
                },
                '}${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'commaop',
                      children: [
                        {
                          type: 'expr',
                          children: [{ type: 'id', children: ['d'] }]
                        },
                        {
                          type: 'expr',
                          children: [{ type: 'id', children: ['d'] }]
                        }
                      ]
                    }
                  ]
                },
                '}...${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['e'] }]
                    }
                  ]
                },
                '}`'
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '-1',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'prefix',
              children: [
                '-',
                {
                  type: 'expr',
                  children: [{ type: 'literal', children: ['1'] }]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '.1e-2',
      [
        {
          type: 'expr',
          children: [{ type: 'literal', children: ['.1e-2'] }]
        }
      ],
      { start: 'expr' }
    );
    ta(
      'f`a${ b }`',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'template',
              children: [
                {
                  type: 'ttag',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['f'] }]
                    }
                  ]
                },
                '`a${',
                {
                  type: 'hole',
                  children: [
                    {
                      type: 'expr',
                      children: [{ type: 'id', children: ['b'] }]
                    }
                  ]
                },
                '}`'
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      '[x,]',
      [
        {
          type: 'expr',
          children: [
            {
              type: 'array',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['x'] }]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
    ta(
      'a - -b // Mixed infix and prefix',
      [
        {
          "type": "expr",
          "children": [
            {
              "type": "infix",
              "children": [
                {
                  "type": "expr",
                  "children": [
                    { "type": "id", "children": [ "a" ] }
                  ]
                },
                "-",
                {
                  "type": "expr",
                  "children": [
                    {
                      "type": "prefix",
                      "children": [
                        "-",
                        {
                          "type": "expr",
                          "children": [
                            { "type": "id", "children": [ "b" ] }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      { start: 'expr' }
    );
  </script>
</details>

<details>
  <summary>More statement tests</summary>
  <script>
    ta(
      '{;}',
      [
        {
          type: 'program',
          children: [
            {
              type: 'block',
              children: [{ type: 'nop', children: [] }]
            }
          ]
        }
      ]
    );
    ta(
      '{;;}',
      [
        {
          type: 'program',
          children: [
            {
              type: 'block',
              children: [
                { type: 'nop', children: [] },
                { type: 'nop', children: [] }
              ]
            }
          ]
        }
      ]
    );
    ta(
      '{;++x;} // ++ attaches to x',
      [
        {
          type: 'program',
          children: [
            {
              type: 'block',
              children: [
                { type: 'nop', children: [] },
                {
                  type: 'expr',
                  children: [
                    {
                      type: 'prefix',
                      children: [
                        '++',
                        {
                          type: 'expr',
                          children: [
                            { type: 'id', children: [ 'x' ] }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      '{;x++;} // ++ attaches to x',
      [
        {
          type: 'program',
          children: [
            {
              type: 'block',
              children: [
                { type: 'nop', children: [] },
                {
                  type: 'expr',
                  children: [
                    {
                      type: 'postfix',
                      children: [
                        {
                          type: 'expr',
                          children: [
                            { type: 'id', children: [ 'x' ] }
                          ]
                        },
                        '++'
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    );
    ta(
      '{ {} ++ i; }',
      [
        {
          type: 'program',
          children: [
            {
              type: 'block',
              children: [
                { type: 'block', children: [] },
                {
                  type: 'expr',
                  children: [
                    {
                      type: 'prefix',
                      children: [
                        '++',
                        {
                          type: 'expr',
                          children: [
                            { type: 'id', children: [ 'i' ] }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    )
    ta(
      'while (b) {}',
      [
        {
          type: 'program',
          children: [
            {
              type: 'while',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['b'] }]
                },
                { type: 'block', children: [] }
              ]
            }
          ]
        }
      ]
    );
    ta(
      'while (b) {} {}',
      [
        {
          type: 'program',
          children: [
            {
              type: 'while',
              children: [
                {
                  type: 'expr',
                  children: [{ type: 'id', children: ['b'] }]
                },
                { type: 'block', children: [] }
              ]
            },
            { type: 'block', children: [] }
          ]
        }
      ]
    );
  </script>
</details>

<h2 id="quantifying-resilience">Quantifying Parser Resilience</h2>

<p>
  To answer &ldquo;How good is this parser at containing damage?&rdquo;
  we collect statistics on how many substrings can be removed from a
  benchmark code sample without affecting the parsing of structures
  on either side.
</p>

<pre class="prettyprint">
outerBefore();
{
  innerBefore();
  <u>f(a/2*'3');</u>
  innerAfter();
}
outerAfter();
</pre>

<p>
  This benchmark code fragment was crafted to include a variety of token types,
  and so that some mutations would introduce new token types like comments and
  regular expression literals.
</p>

<p>
  For each possible substring of the underlined portion, we parse a
  program having removed that substring from the benchmark, and test
  several properties of the resulting AST:
</p>
<ul>
  <li>has outer before: Does the AST contain a call to <code>outerBefore</code>?</li>
  <li>has inner before: Does the AST contain a call to <code>innerBefore</code>?</li>
  <li>has inner after: Does the AST contain a call to <code>innerAfter</code>?</li>
  <li>has outer after: Does the AST contain a call to <code>outerAfter</code>?</li>
  <li>has error: Does the AST contain an error <code>node</code>?</li>
</ul>

<table id="resilience-stats">
  <thead>
    <tr>
      <th>has outer before<th>has inner before</th>
      <th>has inner after<th>has outer after<th>has error</thead>
  <tbody>
</table>

<p>
  The parser reliably parses statements before the mutated statement and in a
  different block.
  The parser fairly reliably parses statements after the end of the block,
  and in the same block but before, but is not perfect;
  removing the substring &ldquo;<code>2</code>&rdquo; produces
  <code class="prettyprint"><u>f(a/*'3');</u></code> and the block comment consumes
  everything after it.
  The parser has mixed success parsing statements that occur after the mutated
  statement in the same block.
</p>

<script>
test(
  () => {
    function doOneTest(code) {
      const tokens = preparseTokens(lex(code));
      const parseTree = parse(tokens);
      const flatParseTree = flattenParseTreeToPseudoTokens(parseTree);
      const { ast: [ ast ] } = toyLanguageGrammar.apply('program', flatParseTree);

      let result = {
        calls: new Set(),
        hasError: false,
      };

      function walk(ast, ancTypes=[]) {
        if (ast.type === 'id'
            && ancTypes[ancTypes.length - 1] === 'expr'
            && ancTypes[ancTypes.length - 2] === 'call') {
          result.calls.add(ast.children[0].tok);
        }
        if (ast.discards) {
          result.hasError = true;
        }
        if (Array.isArray(ast.children)) {
          let { length } = ancTypes;
          ancTypes[length] = ast.type;
          for (const child of ast.children) {
            walk(child, ancTypes);
          }
          ancTypes.length = length;
        }
      }
      walk(ast);

      return result;
    }

    console.group('resilience');
    const testCodeLines = [
      'outerBefore();',
      '{',
      '  innerBefore();',
      '  f(a/2*\'3\');',
      '  innerAfter();',
      '}',
      'outerAfter();',
    ];

    let testCount = 0;
    let hasOuterBeforeCount = 0;
    let hasInnerBeforeCount = 0;
    let hasInnerAfterCount = 0;
    let hasOuterAfterCount = 0;
    let hasErrorCount = 0;

    try {
      const line3 = testCodeLines[3];
      const lineLen = line3.length;
      for (let i = 0; i < lineLen - 1; ++i) {
        for (let j = i ? i + 1 : 0; j < lineLen; ++j) {
          testCodeLines[3] = line3.substring(0, i) + line3.substring(j);
          const {
            calls, hasError,
          } = doOneTest(testCodeLines.join('\n'));
          ++testCount;
          if (calls.has('outerBefore')) { ++hasOuterBeforeCount; }
          if (calls.has('innerBefore')) { ++hasInnerBeforeCount; }
          if (calls.has('innerAfter')) { ++hasInnerAfterCount; }
          if (calls.has('outerAfter')) { ++hasOuterAfterCount; }
          if (hasError) { ++hasErrorCount; }
        }
      }
      function pct(n, d) {
        return html`<span title="${ n } out of ${ d }">${ (n/d * 100).toFixed(2) }%</span>`;
      }
      document.querySelector('#resilience-stats > tbody').innerHTML = html`
        <tr>
          <td>${ pct(hasOuterBeforeCount, testCount) }</td>
          <td>${ pct(hasInnerBeforeCount, testCount) }</td>
          <td>${ pct(hasInnerAfterCount,  testCount) }</td>
          <td>${ pct(hasOuterAfterCount,  testCount) }</td>
          <td>${ pct(hasErrorCount,       testCount) }</td>
        </tr>`;

      const want = {
        hasOuterBefore: 79,
        hasInnerBefore: 78,
        hasInnerAfter:  46,
        hasOuterAfter:  78,
        hasError:  59,
        testCount: 79,
      };
      const got = {
        hasOuterBefore: hasOuterBeforeCount,
        hasInnerBefore: hasInnerBeforeCount,
        hasInnerAfter: hasInnerAfterCount,
        hasOuterAfter: hasOuterAfterCount,
        hasError: hasErrorCount,
        testCount,
      };
      console.log(`Got ${ JSON.stringify(got, null, 2) }`);

      if (JSON.stringify(want) !== JSON.stringify(got)) {
        console.error(`Want ${ JSON.stringify(want, null, 2) }`);
        return false;
      }
      return true;
    } finally {
      console.groupEnd();
    }
  });
</script>


<h2 id="code-as-data">Code as data</h2>

<p>
  The parsing scheme outlined above provides for a limited kind of
  homoiconicity; tools less complex than the compiler can consume
  fragments of code using a small set of parsing rules that readily
  extend to new special forms.
</p>

<p>
  Homoiconicity also makes it easier for programs to operate on or
  produce program fragments.  Quoting from
  <a href="https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20(Bawden).pdf">&ldquo;Quasiquotation
  in Lisp&rdquo; (Bawden 1999)</a>:
</p>

<blockquote>
  <p>
    Quasiquotation is the technology commonly used in Lisp to write
    program-generating programs.
  </p>
  <p>
    &hellip;
  </p>
  <p>
    The backquote character (`) introduces a quasiquotation &hellip;
    Inside the quasiquotation, the comma character (,) marks
    expressions whose values are to be substituted into the result.
  </p>
  <p>
    &hellip;
  </p>
  <p>
    S-expressions were at the core of McCarthy&apos;s original version
    of Lisp.  The ability to manipulate programs as data has always
    been an important part of what Lisp is all about.  But without
    quasiquotation, actually working with S-expressions can be
    painful.
  </p>
</blockquote>

<p>
  So quasiquotation requires two affordances:
</p>
<ul>
  <li>Syntax to &ldquo;quote&rdquo; part of a parse tree.</li>
  <li>Syntax to embed an unquoted expression inside a quoted parse tree.</li>
</ul>

<p>
  <a href="#template-literal-example">JavaScript-esque template literals</a>
  provide this, but run afoul of:
</p>

<blockquote>
  <p>
    The string substitution that underlies [<code>fprintf</code>] has <i>no</i>
    understanding of the syntactic structure of the programming language
    being generated.
  </p>
</blockquote>

<p>
  Javascript&apos;s <i>tagged</i> template literals allow that, but require
  implementing a parser for code with holes and lose source metadata.
  This section shows how this operator precedence scheme can meet the
  goals of quasi-quotation within a C-like language.
</p>

<blockquote>
  <p>&hellip; goals for a successful implementation of quasiquotation:</p>
  <ul>
    <li>
      Quasiquotation should enable programmers to write down what they
    want the output to look like, modified only slightly in order to
      parameterize it.
    <li>
      The parameter expressions should appear inside the template, in
      the positions where their values will be inserted.
    <li>
      The underlying data structures manipulated by quasiquotation should
      be rich enough to represent recursively defined structures such
      as expressions.
  </ul>
</blockquote>

<pre id="unhoist-extra-brackets-for-quasis"></pre>

<p>
  Defining &ldquo;<code>\{</code>&rdquo; and &ldquo;<code>\(</code>&rdquo; as
  bracket operators, enables quoting statements and expressions.
  Defining &ldquo;<code>${</code>&rdquo; as an expression operator allows
  embedding unquoted expressions inside quoted code.
  Then we add some extra productions to the toy grammar, and augment a
  few existing ones.
</p>

<pre id="unhoist-grammar-support-for-quasis"></pre>

<p>
  With that &ldquo;<code>\{</code>&hellip;<code>}</code>&rdquo; embeds
  a parse sub-tree as data.  <span class="type quasi">qtree</span> and
  other bluish AST nodes recreate the parse tree structure of the
  quoted portions.
</p>

<script>
  ta(
    'let blockParseTreeData = \\{ f(\${ x }); };',
    [
      {
        type: 'program',
        children: [
          {
            type: 'decl',
            children: [
              {
                type: 'let',
                children: [
                  { type: 'id', children: ['blockParseTreeData'] },
                  {
                    type: 'expr',
                    children: [
                      {
                        type: 'qtree',
                        children: [
                          {
                            type: 'qinner',
                            children: [
                              {
                                type: 'qinner',
                                children: [
                                  {
                                    type: 'qinner',
                                    children: [{ type: 'qleaf', children: ['f'] }]
                                  },
                                  { type: 'qleaf', children: ['('] },
                                  {
                                    type: 'qhole',
                                    children: [
                                      {
                                        type: 'expr',
                                        children: [{ type: 'id', children: ['x'] }]
                                      }
                                    ]
                                  },
                                  { type: 'qleaf', children: [')'] }
                                ]
                              },
                              { type: 'qleaf', children: [';'] }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
</script>

<p>
  If <span class="type quasi">qinner</span> behaves
  like <span class="type">array</span> and <span class="type
  quasi">qleaf</span> like <span class="type">literal</span> then that
  quasiquotation would produce a tree like data structure.
  The <span class="type quasi">qhole</span>
  breaks back out into unquoted AST nodes that could contribute to the
  larger data structure.
</p>

<p>
  Since &ldquo;<code>\{</code>&hellip;<code>}</code>&rdquo; uses the
  cover grammar, its consumers can recognize forms not allowed by the
  parse-tree &rarr; AST phase.  In this sense, it is similar to Common
  Lisp&apos;s <code>read</code> which recognizes some characters
  (&lsquo;[&rsquo;, &lsquo;]&rsquo;, &lsquo;{&rsquo;, &lsquo;}&rsquo;,
  &lsquo;?&rsquo;, and &lsquo;!&rsquo;) which are not used by Common
  Lisp syntax but which are explicitly reserved for user extensions.
</p>

<blockquote>
  <p>
    List structure is not quite as stark a representation [of code] as
    character strings, but it is still pretty low-level.  Perhaps we
    would be happier if, instead of manipulating lists, our
    quasiquotation technology manipulated objects from a set of
    abstract data types that were designed specifically for each of the
    various different constructs in our language (variables,
    expressions, definitions, <code>cond</code>-clases, etc.).  After
    abandoning character strings as too low-level it seems very
    natural to keep moving towards even highler-level representations.
  </p>
</blockquote>

<p>
  Separately, &ldquo;<code>\(</code>&hellip;<code>)</code>&rdquo;
  quotes an AST with holes.  These two constructs let program
  generators deal with program fragment templates at two different
  levels of abstraction: parse trees and ASTs.
</p>

<script>
  ta(
    'let ifAst = \\( if (\${ x }) { f(\${ x }); } );',
    [
      {
        type: 'program',
        children: [
          {
            type: 'decl',
            children: [
              {
                type: 'let',
                children: [
                  { type: 'id', children: ['ifAst'] },
                  {
                    type: 'expr',
                    children: [
                      {
                        type: 'qast',
                        children: [
                          {
                            type: 'toplevel',
                            children: [
                              {
                                type: 'if',
                                children: [
                                  {
                                    type: 'expr',
                                    children: [
                                      {
                                        type: 'qhole',
                                        children: [
                                          {
                                            type: 'expr',
                                            children: [{ type: 'id', children: ['x'] }]
                                          }
                                        ]
                                      }
                                    ]
                                  },
                                  {
                                    type: 'block',
                                    children: [
                                      {
                                        type: 'expr',
                                        children: [
                                          {
                                            type: 'call',
                                            children: [
                                              {
                                                type: 'expr',
                                                children: [{ type: 'id', children: ['f'] }]
                                              },
                                              {
                                                type: 'actuals',
                                                children: [
                                                  {
                                                    type: 'expr',
                                                    children: [
                                                      {
                                                        type: 'qhole',
                                                        children: [
                                                          {
                                                            type: 'expr',
                                                            children: [{ type: 'id', children: ['x'] }]
                                                          }
                                                        ]
                                                      }
                                                    ]
                                                  }
                                                ]
                                              }
                                            ]
                                          }
                                        ]
                                      }
                                    ]
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  );
</script>

<h3 id="risk-lock-in">Risk: Lock-in</h3>

<p>
  The second kind of quasiquotation exposes details of
  language specification abstracts to user code.  Some language
  designers have expressed concern that this may make it harder to
  evolve the language.
  <a href="https://esdiscuss.org/notes/2018-05-24">On a
  proposal for a binary encoding for EcmaScript AST</a>:
</p>

<blockquote>
  <p>
    <b>WH</b>: compatibility means existing nodes strips compiled
    continue to work as we upgrade the language. But as ECMAScript
    evolves the same text source code may compile to different nodes
    even if they don&apos;t use new constructs.  &hellip; The
    Hyrum&apos;s Law challenge is that folks may come to rely on
    source text compiling to a specific AST.
  </p>
</blockquote>

<p>
  The parse tree form has fewer rules, but there is still a non-zero
  lock-in risk:
</p>

<blockquote>
  <p>
    <b>WH</b>: In this committee it came up discussing changing
    associativity of <code>||</code> from left-to-right to
    right-to-left in order to properly support one of the variants of
    the <code>??</code> proposal.  It&apos;s invisible from within
    ECMAScript but would change which AST gets generated. There was
    opposition related to the effect this would have on Babel&apos;s
    ASTs.
  </p>
</blockquote>

<p>
  In Lisp, the grammar for S-expressions is very simple and stable.
  Without experience maintaining a language whose initial parsing is
  based on cover grammars &amp; precedence table, it&apos;s hard to
  say how stable these are over time, or what strategies are effective
  in working around compatibility problems due to Hyrum&apos;s law.
</p>


<h2 id="limitations">Limitations & CounterExamples</h2>

<p>This parser scheme produces a parse tree that groups tokens for some C-like languages
into a tree that is unambiguous and which can be processed into an AST.</p>

<p>It deals poorly with some idioms and grammatical constructions.</p>

<script>
  function counterExample(input, { parseFn } = {}) {
    const div = document.createElement('div');
    div.className = 'testcase';
    if (document.currentScript) {
      document.currentScript.parentNode.insertBefore(div, document.currentScript);
    } else {
      document.body.appendChild(div);
    }

    deferTest(
      () => {
        const parseTree = (parseFn || parse)(preparseTokens(lex(input)));

        div.innerHTML = html`
          <details>
            <summary>
              <code class="prettyprint">${ input }</code><br>
              ${ formatTNode(parseTree) }
            </summary>
            <pre>${ JSON.stringify(parseTree, replaceTokenWithTokenText, 2) }</pre>
          </details>`;
      });
  }
</script>

<h3 id="angle-bracket-ambiguity">Angle bracket ambiguity</h3>

<p>As <a href="#bracket-ambig">previously discussed</a>, there is a deep,
unavoidable ambiguity between &lsquo;&lt;&rsquo; as a comparison operator and
as a bracket around type parameters.</p>

<script>
  counterExample('template <class T> T mode(vector<T>& xs)');
  counterExample('unnecessary_statement_label: a < b && c > d && sideEffect();');
</script>

<p>
  Unless there is a closed set of operators that precisely distinguish
  type contexts from exception context, this is incorrigible.
  <code>template</code> could be defined as a prefix operator, but
  operator precedence parsing cannot take into account facts like
  &ldquo;<code>vector</code> is a type name&rdquo; without
  CF-violating entanglements.
</p>

<h3 id="flow-control-without-brackets">Flow control without brackets</h3>

<script>
  counterExample('if (cond) --x;');
</script>

<p>This is subideal because the low precedence &ldquo;<code>--</code>&rdquo; operator
  captures the apparent function call <code>if (cond)</code> since it can function
  as both a prefix and postfix operator.
  This can be partially fixed by defining <code>if</code> and friends as low-priority
  prefix operators, as is already done for <code>do</code>.
</p>

<script class="visible">
function altCanNest(outers, inner) {
  let outer = outers(0);
  if (outer.op.tok === '{' && outer.op.type === INFIX
      && inner.op.tok === 'if') {
    return true;
  }
  return canNest(outers, inner);
}

const { parse: altParse } = makeParser(
  new ClosedOperatorSet([
    ...operators,
    { type: PREFIX, tok: 'if', prec: -1 },
  ]),
  altCanNest);
</script>

<script>
  counterExample(
    'if (cond) --x;',
    { parseFn: altParse }
  );
</script>

<p>The <code>if</code> node is now self contained, but without some
invisible adjacency operator auto-inserted between the close
parenthesis and <code>--</code> the parse tree is still odd.  Worse,
the <code>--</code> acts as a postfix operator on <code>if</code> so this
alternate nesting scheme would require extra rules to prevent postfix
operators applying to <code>if</code>.
</p>

<p>Worse, this is no longer homoiconic.  New operators that want to syntactically mimic the
structure of <code>if</code> need to have their own entry in the precedence table.</p>

<h3 id="else-else-if">Else Else If</h3>

<p>
  The <a href="#cover-grammar">cover grammar</a> allows
  <code>else if</code> to follow <code>else</code> which might
  introduce some shift-reduce style problems.  This may be corrigible
  by tweaking <code>canNest</code> with respect to a
  prefix <code>if</code> and infix <code>else</code> or by
  recognizing <code>else if</code> as a separate, two token infix
  operator in <i>preparseTokens</i> as for Python-esque
  <tt>not in</tt> and <tt>is not</tt>.
</p>

<p>
  This is not a problem when the language requires brackets around
  <tt>if</tt> bodies as the toy language does.
</p>

<script>
  counterExample(
    'if (a) if (b) x; else y; else if (c) z;',
    { parseFn: altParse }
  );
</script>

<h3 id="flow-control-without-parentheses">Flow control without parentheses</h3>

<p>Go makes parentheses optional around flow control constructs; it
uses <code class="prettyprint">for init;cond;incr { }</code> instead
of <code class="prettyprint">for (init;cond;incr) { }</code>.</p>

<script>
  counterExample('if a && b { doTheThing() }');
</script>

<p>This is subideal because the low priority <code>&&</code> operator captures the higher
  priority infix <code>{}</code> operator.
  Again, defining infix curly brackets as low-priority can probably address this
  but the author has not proven this.
  (TODO: try this.  It shouldn&apos;t break do{}while)
</p>

<script>
  counterExample('if a && b { doTheThing() }', { parseFn: altParse });
</script>

<h3 id="scoping">Scoping</h3>

<p>It would be nice if tools could make high-quality-ish conclusions about chunks of
a program.  One of the most important things is to match declarations with uses, which is
often a prerequisite to identifying free variables.</p>

<p>The author has been unable to find a generic algorithm that identifies declarations.</p>

<p>It is generally the case that in <code class="prettyprint">keyword
(...) {...}</code>  any declarations immediately inside the
parentheses are in scope for the code in the curly brackets.</p>

<p>This is not sufficient.

<ol>
  <li>
    <p>To recognize a declaration in C, C++, and Java, you need to have a list of symbols that are
    type names.  For example, in C++, <code>{x * y;}</code> is a declaration of a pointer when
    <code>x</code> is a type name, or an invocation of the infix &lsquo;*&rsquo; operator when
    it is not.</p>

    <p>In Java, inner classes can be inherited, so local analysis is not
    sufficient to tell whether <code>x.y.z</code> is a reference to a static member of
    unqualified type <code>x</code>, a reference to a member of a (possibly inherited)
    field <code>x</code>, or a reference to a static member of a class with the absolute
    name <code>x.y</code>.</p>

    <p>Languages that consistently set declarations apart with a keyword
    like <code>let</code>, <code>const</code>, <code>val</code>,
    or <code>var</code> could define those as prefix operators and
    may avoid this problem.</p>
  </li>
  <li>
    <p>Code inside a class declaration in languages like Java and C++ inherit masking symbols,
      so you need to understand the inheritance structure to draw conslusions about variables
      in scope.
    </p>

    <p>Languages that require <code>this.x</code> to access fields, or that shorten this to
    <code>.x</code> by defining &lsquo;.&rsquo; as a prefix operator can avoid this problem.</p>
  </li>
</ol>

<h2 id="suggestions">Suggestions</h2>

<p>If you wish your language to be parseable by schemes like this:</p>

<ul>
  <li>
    Divide parsing into these stages:
    <ol>
      <li><a href="#lexing">Lexing</a>: breaking the input into tokens.
        (See <a href="#scannerless">note on scannerless parsing</a>.)</li>
      <li><a href="#token-preparsing">Preparsing</a>: inserting synthetic tokens to group
        complicated lexical constructs like template literals or JSX/E4X tags.</li>
      <li><a href="#parsing">Parsing</a>: deriving a parse tree from the token stream</li>
      <li><a href="#well-formedness">Checking</a>: checking the parse tree for well-formedness</li>
      <li><a href="#combinators">Abstracting</a>: converting the parse
        tree to an AST (abstract-syntax-tree) which is a suitable input
        to a compiler or interpreter.</li>
    </ol>
    Document each so that tools can operate at an appropriate level.
  <li>
    Do not do work <a href="#before-lexing">before lexing</a> except to decode
    from well-formed, strict UTF-8 so that tools do not have to guess
    character encodings.
  <li>
    Follow Unicode
    <a href="https://unicode.org/reports/tr31/#normalization_and_case"
       >recommendations for identifiers</a>
    which means converting identifiers to a normal-form.
    The well-formedness <a href="#nfc-test">checks</a>
    warn on identifiers that are not in NFC.  Doing this then, instead
    of during parsing or lexing, catches any programmatically
    generated, unnormalized identifiers.
  <li>
    Avoid <a href="#bracket-ambig">angle bracket ambiguity</a>.
    <ul>
      <li>Do not use <code>&lt;&hellip;&gt;</code> to group type parameters.
        For example, Scala
        <a href="https://docs.scala-lang.org/tour/generic-classes.html">uses
          <code>[&hellip;]</code>
        </a>.
      <li>or ensure that lexical analysis (a left to right pass over
        tokens that may keep a bracket stack) alone can disambiguate.
        It is important to be able to distinguish, without a list of type names:
        <ul>
          <li>Parentheses that group formal parameters from those that group
            actual parameters.</li>
          <li>Declarations from assignment statements.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Craft declaration and flow control constructs to fit within the
      <a href="#cover-grammar">cover grammar</a> modulo explicitly
      handled legacy constructs like <code>do...while...</code> and
      <code>switch(...){case...:...}</code>.</p>
    <p>Specifically:</p>
    <ul>
      <li>require parentheses unlike Go and Swift</li>
      <li>make brackets non optional like Go and Swift</li>
    </ul>
  </li>
  <li>
    <p>Avoid layered namespaces like Java&apos;s layering of explicitly
    imported type names, wildcard imported type names, explicitly
    imported static properties and methods, wildcard imported
    properties and methods, local identifiers, inherited properties
    and methods.</p>

    <p>Make local identifiers always mask external definitions and
    maybe use a lightweight convention like <code>.identifier</code>
    instead of just <code>this.identifier</code> so that tools can
    confidently distinguish local references from references that can
    only be resolved with knowledge from other source files.</p>
  </li>
  <li>
    <p>
      If you must automagically insert semicolons,
      <a href="#tool-inserted-semicolons">leave it to tools</a>
      like IDEs, and do it based on <a href="#lexical-asi">lexical analysis</a>.
    </p>
  </li>
</ul>

<h2 id="summary">Summary</h2>

<p>
  Separating parsing of coarse-level structure from fine-grained
  structure provides benefits including: better tool support during
  development, easier partial program analysis, language
  extensibility, and metaprogramming.
</p>

<p>
  Some simple guidelines make it easier to craft a new language that
  gets these benefits and uses a syntax familiar to developers who
  work with widely-used, C-like languages.
</p>

<p>
  Ambiguity between less-than &amp; angle-brackets means that not all
  existing languages cannot be migrated to this scheme, although,
  strangely, some complex languages like TypeScript may be migratable.
  There are clear precedents that show how to design around this ambiguity.
</p>

<p>
  That ambiguity avoided, operator precedence parsers can parse C-like
  languages.  (Operator precedence parsers have not been widely used
  for parsing C-like languages, except in conjunction with RD, though
  Perl 6&apos;s
  <a href="https://www.pmichaud.com/2006/pres/yapc-parsers/slide28.html">Parser Grammar Engine</a>
  may be one precedent.)
</p>

<p>
  This operator precedence parser degrades gracefully given partial
  and broken inputs.  It combines a small fixed set of rules with an
  extensible operator partial-order, so also meets the extensibility
  goal.
</p>

<p>
  The same techniques that allow grammar extensibility, also allow
  extensible quasiquotation and use cases enabled by Common
  Lisp&apos;s <code>read</code>.
</p>



<h2 id="try-it-out">Try it out</h2>

<table id="tio-table">
  <tbody>
    <tr>
      <th>Input</th>
      <td><code id="tio-input"></code></td>
    <tr>
      <th>Tokens</th>
      <td id="tio-tokens"></td>
    <tr>
      <th>Parse Tree</th>
      <td id="tio-parse-tree"></td>
    <tr id="tio-problems-row">
      <th>Problems</th>
      <td id="tio-problems"></td>
    <tr>
      <th>Flat Tree</th>
      <td id="tio-flat-tree"></td>
    <tr>
      <th title="abstract syntax tree">AST</th>
      <td id="tio-ast"></td>
    <tr>
      <th>Parts of Speech</th>
      <td id="tio-pos"></td>
</table>

<script>
  // Handles the Try it out form.  Fills the output table from form inputs.
  function tryItOut(srcText) {
    const table = document.getElementById('tio-table');
    const prodsel = document.getElementById('production-select')

    console.group(srcText);
    try {
      table.querySelector('#tio-input').textContent = srcText;

      let problem = false;
      let tokens = [];
      try {
        tokens = Array.from(preparseTokens(lex(
          srcText,
          {
            onLexError() {
              problem = true;
            }
          })));
      } catch (ex) {
        console.error(ex);
        problem = true;
      }

      table.querySelector('#tio-tokens').innerHTML =
        formatTokens(tokens, problem);

      let parseTree;
      try {
        parseTree = parse(tokens);
      } catch (ex) {
        parseTree = ex instanceof Error ? ex : new Error(ex);
        console.error(ex);
      }

      table.querySelector('#tio-parse-tree').innerHTML =
        parseTree instanceof Error
        ? html`<i>${ parseTree.message || 'Error' }</i>`
        : formatTNode(parseTree);

      let ast = new Error('parse tree unavailable');
      let flatParseTree = ast;
      let problems = ast;

      if (!(parseTree instanceof Error)) {
        try {
          problems = checkParseTree(parseTree);
        } catch (ex) {
          problems = ex instanceof Error ? ex : new Error(ex);
          console.error(ex);
        }
        try {
          flatParseTree = flattenParseTreeToPseudoTokens(parseTree);
        } catch (ex) {
          flatParseTree = ex instanceof Error ? ex : new Error(ex);
          console.error(ex);
        }
      }

      table.querySelector('#tio-problems').innerHTML =
        problems instanceof Error
        ? html`<i>${ problems.message || 'Error' }</i>`
        : formatProblems(problems);
      table.querySelector('#tio-problems-row').style.display =
        Array.isArray(problems) && problems.length === 0 ? 'none' : '';
      if (Array.isArray(problems)) {
        table.querySelector('#tio-input').innerHTML = wiggles(srcText, problems);
      }

      table.querySelector('#tio-flat-tree').innerHTML =
        flatParseTree instanceof Error
        ? html`<i>${ flatParseTree.message || 'Error' }</i>`
        : html`${ JSON.stringify(flatParseTree, replaceTokenWithTokenText) }`;

      if (!(flatParseTree instanceof Error)) {
        try {
          ast = new Error('grammar application failed');
          let result = toyLanguageGrammar.apply(prodsel.value, flatParseTree);
          if (result && result.ast) {
            ast = result.ast;
          }
        } catch (ex) {
          ast = ex instanceof Error ? ex : new Error(ex);
          console.error(ex);
        }
      }

      table.querySelector('#tio-ast').innerHTML =
        ast instanceof Error
        ? html`<i>${ ast.message || 'Error' }</i>`
        : formatAst(ast && ast.length === 1
                    ? ast[0] : { type: 'forest', children: ast });

      let groupedPartsOfSpeech = new Error('Tagging failed');
      try {
        groupedPartsOfSpeech = groupPartsOfSpeech(tagPartsOfSpeech(tokens));
      } catch (ex) {
        groupedPartsOfSpeech = ex instanceof Error ? ex : new Error(ex);
      }

      table.querySelector('#tio-pos').innerHTML =
        groupedPartsOfSpeech instanceof Error
        ? html`<i>${ posTokens.message || 'Error' }</i>`
        : formatPartsOfSpeech(groupedPartsOfSpeech);
    } finally {
      console.groupEnd();
    }
  }

  function updateTryItOutForm() {
    setTimeout(() => tryItOut(document.getElementById('tio-inp').value), 0);
  }

  function populateTryItOut(input) {
    const prodsel = document.getElementById('production-select')
    const tioInp = document.getElementById('tio-inp');

    prodsel.value = /[;{]/.test(input) ? 'program' : 'expr';
    tioInp.value = input;
    tioInp.scrollIntoView();
    updateTryItOutForm();
    tioInp.focus();
    tioInp.select();
  }
</script>

<p>&uarr; Output, &darr; Input</p>
<form target="#" onsubmit="updateTryItOutForm(); return false">
  <select id="production-select"></select><br>
  <textarea style="font-family: sansserif" cols="80" rows="10" placeholder="C-like tokens"
            spellcheck="false" id="tio-inp"
            onfocus="this.select()">for (let i : number = 0, n = 10; i < n;) {
  (foo += i++ * 123);
}</textarea>
  <br>
  <button style="font-size: 150%" type="submit">Parse and display</button>
</form>

<script>
document.getElementById('production-select').innerHTML = html.join(
  [...toyLanguageGrammar.productionNames()].sort().map(
    (name) =>
      html`<option ${ name === 'program' ? 'selected' : '' }>${ name }</option>`
  ));
</script>

<script src="../js/toc.js"></script>
<script src="../js/navbar.js"></script>

<script>
  // Check that links to internally defined anchors are not broken.
  test(
    () => {
      let pass = true;
      console.group('Checking internal links');
      try {
        for (const a of document.querySelectorAll('a[href^="#"]')) {
          const url = a.getAttribute('href');
          if (!document.querySelector(url)) {
            console.error(
              'Broken link to %s with text `%s`: %o',
              url, a.textContent, a);
            pass = false;
          }
        }
      } finally {
        console.groupEnd();
      }
      return pass;
    }
  );
</script>

<script>
  // Check that visible scripts don't have overly long lines
  test(
    () => {
      console.group('Long line check');
      try {
        for (const script of document.querySelectorAll('script.visible')) {
          let longLine = /.{81,}/;
          let match = longLine.exec(script.textContent);
          if (match) {
            console.error(`Overly long line: ${ match[0] }`);
            return false;
          }
        }
      } finally {
        console.groupEnd();
      }
      return true;
    }
  );
</script>

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/prettify.js"></script>
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/prettify.css">

<script>
  updateTryItOutForm();
  runDeferredTests();
</script>


<script src="../js/visible-scripts.js"></script>

<div style="color:#888; text-align: center"><small>Thanks for reading!</small></div>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-149540884-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-149540884-1');
</script>
